%%:uuid=180228120827003
### Nginx
#### I/O类型
- http协议的核心要点:
    - 监听在tcp/80端口
    - URL格式: scheme://server[:port]/path/to/source[参数或者片段]
- http事务: request<----->response
    - 协议格式一般有两种: 文本格式和二进制格式
- 浏览器一般都是多线程,针对每一个域名开放n个线程,所以现在很多网站通过下面这个手段来优化: 网站内部的资源分布在x个域名上,然后客户端的浏览器就会同时开放2x个线程加载这一个网站,从而达到优化的目的
- 从不同角度划分有两种方式:关注的是消息通知机制,说白了就是如何通知调用者的
    1. 同步IO, Synchronous,调用发出后,不会立即返回,一旦返回,返回的即是最终结果;没有通知的就是同步
    2. 异步IO, Asynchronous, 调用发出后,被调用方立刻返回消息,但返回的并非最终结果,被调用者通过状态,通知机制等来通知调用者,或通过回调函数来处理结果;有通知的就是异步的
- 阻塞和非阻塞:关注的是调用者等待被调用者返回调用结果时的状态
    1. 阻塞,block, 调用结果返回前,调用者会被挂起(不可中断睡眠状态),调用者只有在得到返回结果之后才能继续, 去新开的店吃饭, 在厨师做饭的时候只能等
    2. 非阻塞,nonblock, 调用者在调用结果返回之前不会被挂起,即调用不会阻塞调用者; 去熟悉的店吃饭,点完餐,去隔壁网吧玩一把,然后回去吃饭
- 常用的5种I/O模型;SELECT在实现多路I/O时,fd是有限的1024;
    1. blocking I/O 阻塞式I/O
    2. nonblocking I/O 非阻塞式I/O
    3. I/O multiplexing 复用型I/O; select()调用BSD风格,poll()调用SysV风格,这俩组件功能其实一样;他们可以理解为是被调用者的助理,调用者的请求就都是扔给这些助理的;其实复用型I/O也是阻塞型的I/O,只不过不是阻塞在自己那个真正的调用I/O上,而是阻塞在SELECT上.
    4. Signal driven I/O 事件驱动式I/O ;内核会通知进程,内核数据准备完成,但是数据从内核内存到进程内存也还是阻塞的;事件驱动型I/O的好处就是一个进程可以响应n个请求; 引入了通知机制: 1) 水平触发,你不处理,就重复通知,直到你处理为止,可以多次通知,相对比较浪费资源; 2) 边缘触发,只通知一次.
    5. Asychronous I/O 异步I/O, 内核收到进程的请求后,让进程该干嘛干嘛去,内核默默地在后台完成加载数据到内核内存 和 复制内核内存中的数据到进程内存中,然后再通知进程,进程再打包数据发送给客户端. 对性能的提升非常大: 比如多个用户请求同一个资源,这个资源的I/O还缓存在内存中,就会大大的节省时间
    ```
    // 举例理解I/O,一次read操作,当一个进程向内核发起I/O调用后大体有两步:
    1. 内核把数据从磁盘加载到内核自己对应的内存中
    2. 数据从内核内存中复制到进程内存中
    // 进程发起I/O请求后要等待两个阶段: 1.数据从磁盘到内核内存 2.数据从内核内存复制到进程内存;其中真正称为I/O的是数据从内核内存复制到进程内存的过程
    ```
#### Nginx介绍
- Nginx是一款web服务器,同时也是一款外部(反向)代理.
