%%:uuid=170815155922001
### 邮件服务系列之基础原理
- 邮件服务的协议:
    - smtp: Simple Mail Transfer Protocol 简单邮件传输协议;仅仅实现将邮件从发送方传输到接受方
    - esmtp: Extended Simple Mail Transfer Protocol 扩展的简单邮件传输协议,可以验证用户是否支持身份认证功能了,但本身并不能实现身份认证功能,仅仅是检测.
    - pop3: Post Office Protocol Version3, 邮局协议
    - Imap4: Internet Mail Access Protocol Version 4,功能和pop3相似,有一个就可以,但是IMAP4更强大,消耗的资源也更多
    - 历史: UUCP: Unix to Unix CoPy,就是在多个UNIX主机之间传输文件的协议;协议和功能非常简陋,于是不久就出现了SMTP协议,简单来讲,就是实现将文件从一个主机传到另外一个主机,而且smtp协议本身可以实现路由功能,实现传输路由.
    - SMTP也是C/S架构,假设服务器端(smtpd),客户端smtp(sendmail);
    - UNIX主机如何实现多用户的:互联网刚刚诞生的时候,还没有PC机,几乎每一个用户都是UNIX主机上的用户,用户被成为Mainframe或者小型机上的用户,每个用户都有家目录;那么用户是怎么链接主机的呢,我们可以理解为,主机上有个分屏器,分屏器上有许许多多的接口,每个用户只要提供一个显示器和键盘,通过所谓的线路,就可以链接到分屏器,所以我们就可以把这个显示器和键盘成为终端;那么现在的虚拟终端,就是模拟多个用户同时登陆主机的场景的,只不过没那么多物理设备了.
    - 假设一个用户需要发送邮件到另外一台主机上的用户的时候,加入发送方所在的域叫a.org; 接受方为 b.net;tom@a.org 该怎么发送邮件给jerry@b.net呢? 首先tom通过文本编辑器写好邮件,且本地肯定有个邮件客户端,jerry那边肯定有个服务器端.然后tom这边的客户端,先向DNS查询jerry所在域(b.net)的mx记录,mx可能是一个主机(很可能是mail.b.net),mail.b.net还是个域名,还得进一步将它解析为A记录(IP地址),万一接收方域内有多个的MX记录,找优先级最高的那个;然后发送方的客户端就去链接接收方服务器所监听的端口(SMTP监听在tcp/25号端口,客户端的端口号是随机的,一般来讲是大于5000的).如果发现jerry就是这台主机上的用户
    - 所以在服务器上一定有一个目录,目录里面,每一个用户都应该有自己对应的邮筒,当邮件到达后,服务器发现邮件接收方确实是本机上的用户,服务器就把邮件放到对应用户的邮筒;每一个用户的邮筒都是和用户同名的__文件__.当对应的用户登陆的时候,就会有一个脚本程序会通知用户,用户用`mail`就可以把邮件取出来放到家目录里,邮箱里就没了;也就是说用户看过的邮件都在用户的家目录里,叫mbox.
    - 从客户端到服务器端之间,这一段用到的协议叫做smtp协议;当邮件到达服务器方以后,服务器方发现接收方确实是本机用户后,邮件存放到用户邮筒的过程并不是有SMTP协议完成的,SMTP仅负责邮件的传输(MAIL TRANSFER),存放的过程是由邮件投递(MAIL DELIVERY)的组件完成的,这个组件有个统称叫做邮件投递代理(MDA: Mail Delivery Agent)
    - 事实上,邮件服务器真正的工作模型:每一个用户使用编辑邮件的工具,提交发送的工具就是个客户端,它是将邮件送往本地服务器的,它它并不是直接联系远程服务器,而且这个工具也不是SMTP工具,这个用户我们把它成为邮件用户(MAIL USER),这个工具我们成为邮件用户代理(Mail User Agent);同样能够接收邮件的服务器端也有个统称叫做MTA(Mail Transfer Agent).
- 整理邮件工作机制:用户要发送邮件,首先要拿着一个可以编写邮件并且可以发送邮件的工具来向外发送邮件,这个工具是邮件用户代理(Mail User Agent),会向用户提供一个编写邮件的界面(参考outlook);邮件写好之后并不是直接发往目标服务器的,任何一个邮件用户代理都有一个自己所允许提交邮件的目标服务器,一般都是本地的;然后邮件由这个服务器负责分拣来判定邮件是发往何处的;这目标又分为两类:1) 本地邮件传输,就是接收方是本机用户的lmtp:local mail transfer protocol;2) 当邮件接收方不是本机用户时,邮件服务器就会调用__客户端__(smtp),由客户端来连接目标主机的服务器端;接受放服务器接受邮件以后由MDA进行投递,接收方用户登陆以后使用自己的MUA查看邮筒里的邮件,查看以后保存到自己的家目录.
- 当别人发来邮件,是本地的就接受,不是本地的就转发的功能,就叫开放式中继open relay,有极大的被滥用的风险,所一般我们不允许中继,但是在本地服务器端判断邮件是发往其他主机还是本机用户的时候也是有一次中继操作的;所以我们至少要允许本机用户中继;但是家贼难防,所以我们可以基于用户来认证.
- 在SMTP协议上,发件人是可以随意伪装的,这是有巨大的风险的,应该认证用户.SMTP需要借助于额外的认证工具来实现认证,这个工具还要通过简单认证安全曾协议SASL(Simple Authentication and Security Layer)来完成,也就意味着我们的服务器上需要安装SASL服务器,STMP服务器内部有个小程序,可以让SMTP成为客户端,当某个用户要发邮件的时候,SMTP就可以把用户的账号提交给SASL服务器,又SASL服务器来验证本地是否有这个用户.
- POP3:我们上面说的都是用户在服务器上有家目录,且登陆服务器的场景,现在大家都是有PC机的,首先PC不可能做成SMTPD服务器,也不可能24小时在线,MTP是要求24小时在线,当传输邮件的时候发现你不在线,尝试几次重连之后就直接丢弃邮件了.POP3就是是用来解决MDA和接受方的MUA之间的连接;所以我们就需要一个服务器24小时接收邮件,哪一个用户连接到这个服务器,这个服务器就以谁的身份去检索邮件,并传递给邮件用户代理MUA,这个程序统称为邮件检索MRA(Mail Retrieval Agent);这个协议就叫POP3协议.
- 在网页上就可以收邮件写邮件是如何实现的: 那么我们就需要web服务器了,还需要开发一个可以写邮件的程序,点击发送的时候递交给SMPT的客户端,由它来联系SMTP服务器,收邮件的时候,让web服务器作为pop3的客户端.这样的机制叫做WEBMAIL.
- 为了保证邮件服务器的安全性,我们的SMTP需要借助于SASL来检索用户的账号密码,POP3服务器也需要做用户认证,否则所有人都可以冒名查看别人邮件了.很显然这些用户并不是系统用户,比如网易邮箱的用户基数非常大.
- 于是我们就需要关系型数据库了;当我们的用户量超大的时候,检索速度就很慢,LDAP协议:轻量级目录访问协议Lightweight Directory Access Protocol 把数据按照目录的格式进行组织,检索速度无以伦比的快,但是它也有缺陷:写的速度非常慢,比关系型数据库要慢一个数量级,所以ldap比较适合一次写入,多次读取.LDAP到现在为止并不是非常成熟;比较适合于大规模用户账号系统,资源检索系统.目前对LDAP协议实施最好的是WINDOWS SERVER,叫做Windows ActiveDirectories.不过不到上亿的用户级别是用不到的.
- 虚拟用户:仅用于访问某服务的数字标识,只是个字符串而已.现在的POP3服务器都有MYSQL的访问驱动,也有LDAP的访问驱动;SASL是没办法到MYSQL中检索用户的,只能到/etc/shadow中检索,所以SASL需要其他组件到MYSQL中检索账户.
### 邮件服务系列之编译安装postfix-2.10.0
#### MTA: 邮件传输代理,是一个统称,它是一种协议,我们可以把它理解为一种程序,一种服务器,而能够提供MTA服务的软件有很多,常用的有:- 
- Sendmail:最著名的,出现在SMTP协议之前,在UUCP时代就出现了,是互联网邮件系统的鼻祖,当前也占据了邮件服务器的半壁江山;不过正因为它出现得过早,它的设计理念也就不太符合当今的需求,只不过众多邮件系统都是很久以前设计的,到今天如果我们贸然把它换掉,成本非常高,这就是至今,sendmail市场占有率还很高的原因.
- sendmail是一个单体结构,也就是说所有功能都是由一个进程来实现,所以任何一个进程出现风险,都有可能波及整个邮件服务器,而sendmail有些程序的执行还要利用到suid,所以这也是非常不安全的;sendmail的配置文件用的是M4编写的,非常难以理解.
- 然后一个数学家开发了另外一款软件,比sendmail体积小很多,整个不到1M大小,但是发送邮件的效率可以达到sendmail的20倍左右,这就是Qmail,但作者两三年后就不玩了,抛弃了Qmail,现在Qmail很少人用了,不过有些商业化邮件服务器内核还是Qmail的.
- postfix,开源MTA三剑客的第三个,是MTA中的新贵,其作者是sendmail的爱好者,是IBM安全领域的专家,他的设计就是力图避免sendmail的缺陷,保持sendmail的优势,于是postfix采用了模块化设计,每一个功能都尽可能用一个模块来实现,而且避免suid,更是在一开始就注入了邮件服务器安全的观念,作者的目的是取代sendmail,所以postfix跟sendmail的兼容性非常好,投掷效率也大概是sendmail的4倍以上;所以现在新的邮件系统一般都是采用postfix.
- 剑桥大学也有一款很著名MTA:exim,语法简单,使用简易,在一定区域内也非常出名
- Exchange:只能安装在windows上,不仅仅能发送邮件,还是一个异步消息协作平台,可以共享日历等等,他必须和windows的ldap结合起来,所以一般要使用exchange,windows上还要安装上AD(Windows ActiveDirectories);Exchange非常重量级,有几个G,而一个postfix才几M.
#### MDA:邮件投递代理
- 绝大多数的邮件传输代理(MTA)都整合了邮件投递代理,比如postfix自带了投递代理(其实就是一款软件)
- sendmail使用的MDA是procmail
- 毛子研发过一整套邮件系统,maildrop是其中一个组件,专门用于邮件投递代理,在邮件投递时,可以实现垃圾邮件过滤的,不过它的语言是M4,比较难以理解;maildrop是一款非常专业的邮件投递代理
- 很多场景中,我们很有可能为postfix提供maildrop来实现邮件投递
- 实际上postfix附带的投递代理有两个,一个是本地用户邮件投递代理,一个是虚拟用户邮件投递.
#### MRA(POP3,IMAP4):邮件检索代理,能够让用户连上来并检索邮件的代理
- cyrus-imap
- dovecot:鸽子笼,功能强大,配置简单
#### MUA: 邮件用户代理
- outlook express(简装版),outlook(和office一起安装)
- foxmail
- thunderbird(linux 图形化)
- Evolution(Linux)
- mutt(文本界面)
#### WebMail
- Openwebmail(湾湾研发的,和sendmail结合起来工作的,是perl研发的)
- Squirrelmail (redhat自带的松鼠邮件,php研发的)
- Extmail(Extman 管理界面),国人研发的,现在开始做商业化了,他们定制了CentOS,里面集成了Extmail,所以他们的系统也叫EMOS, Extmail也是用perl开发的,界面类似于126邮箱界面
#### SASL服务器:saslauthd
- cyrus-sasl: 有v1和v2版本,我们现在大部分都用的V2版本
- sasl本身只是一个认证平台(认证框架),它本身并不负责实现认证,要想实现认证我们还需要用到各种专业级的认证组件;就好比我们建了一所房子,为了防贼,我们在房子外面设置了围墙,围墙上可能是电网,可能是玻璃渣;这个围墙就像是sasl,而电网或者玻璃渣就是认证组件;我们常用的认证组件是一个美籍毛子在他一个项目中使用的套件:courier,套件中含有mta,mda,mra,但是它的mta没有postfix的好,所以我们通常都是拿postfix当MTA,拿courier-authlib来完成到mysql或者ldap中完成认证
#### 部署过程
- 发邮件:`postfix + SASL (courier-authlib 到mysql中认证 + Mysql)`
- 收邮件 `Dovecot + MySQL`
- WebMail: Extmail + Extman + httpd
- redhat给我们提供了postfix的rpm包,但是它编译的时候不支持基于sasl到虚拟用户的认证
- smtpd默认监听的是tcp/25端口,我们查看发现25号端口已经被监听了:
    ```
    [root@localhost etc]# netstat -tlunp
    Active Internet connections (only servers)
    tcp        0      0 ::1:25                      :::*                        LISTEN      2021/master  
    // 说明系统上已经有一个邮件服务器了,RHEL6默认安装的就是postfix,RHEL装的是sendmail 
    ``` 
- linux系统默认是安装了邮件系统,且默认启动的,因为系统上很多自动化任务需要通过邮件服务器向管理员通知及执行信息的
- 我们要先停止并卸载系统安装的邮件系统
    ```
    [root@localhost etc]# service postfix stop
    Shutting down postfix:                                     [  OK  ]
    [root@localhost etc]# chkconfig postfix off
    [root@localhost etc]# chkconfig --list postfix
    postfix        	0:off	1:off	2:off	3:off	4:off	5:off	6:off
    // 如果我们不卸载,到此步就可以了
    [root@localhost etc]# rpm -e postfix    //报错,提示 postfix被别的程序依赖
    error: Failed dependencies:
    	/usr/sbin/sendmail is needed by (installed) cronie-1.4.4-12.el6.x86_64
    	/usr/sbin/sendmail is needed by (installed) redhat-lsb-core-4.0-7.el6.centos.x86_64
    [root@localhost etc]# rpm -e postfix --nodeps   //因为我们还要安装,所以这里忽略依赖,强行卸载
    ``` 
- 编译安装postfix，我们要安装的postfix将来是要跟mysql联合起来，将来能够实现虚拟用户的，所以我们要先安装好mysql
    ```
    [root@localhost mail]# tar xf postfix-3.2.2.tar.gz 
    [root@localhost mail]# ls
    postfix-3.2.2
    [root@localhost mail]# cd postfix-3.2.2
    [root@localhost postfix-3.2.2]# 
    ```
    
    TODO
