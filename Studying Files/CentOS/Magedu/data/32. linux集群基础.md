%%:uuid=180306101723001
### 学习规划
- Linux Cluster主要两类:
    - LB集群: Load Balancing,负载均衡
    - HA集群: High Availability,高可用
    - HP集群: High Permormance,大规模并行处理分析平台;分布式存储及并行处理集群
- WEB Arch: web的高级应用
- 虚拟化和云计算
- 自动化运维工具:ansible,puppet,zabbix
- 大数据处理平台: hadoop 2, storm, spark, zookeeper
- PaaS,ELK

##### LB集群，负载均衡
- 集群: Cluster，将多台主机组织起来，处理统一问题.
- 系统扩展的思路:
    - scale up: 向上扩展,用性能更好的主机替代当前主机,消耗的代价和带来的性能提升是不成正比的.
    - scale out: 向外扩展,当主机难以负载现有的需求时,我们就加主机,把请求分散到诸多主机上;向外扩展其实面临很多问题

##### HA集群,高可用
- `衡量一个系统的可用性(Avalability)=无故障时间/(无故障时间+修复时间)`

##### 还有另外一种常见的集群，大规模并行处理分析平台;分布式存储及并行处理集群
- mapreduce：映射缩减；比如hadoop

#### 系统
- 衡量一个系统通过以下几个方面:
    - 可扩展性
    - 可用性
        - 服务是否随时可用
        - 容量的衡量：比如高速公路上，在多大密度下，可以通过多少量车
        - 性能：可以理解为单位时间内的通过量
    - 系统运维:对大量主机组成的系统来讲, `可用 --> 标准化 --> 自动化`
- 构建高可扩展性系统的重要原则: 在系统内部尽量避免串行化
- GSLB: Global Service Load Balancing; 在多城市,多机房部署负载均衡系统. SLB：本地负载均衡系统
- 缓存都是以KV(key value)结构存储的,有可能存储在文件系统上,键比对速度会非常快.
- 总结：
    - 分层：`负载均衡层 --> 静态内容层 --> 动态内容层 --> 数据存储层` 让没一个服务器各司其职
    - 分割: 如果一个系统把所有功能糅合在一块,它会变得很复杂;我们可以把不同应用分割到不同的服务器组上
    - 分布式: 分不了层的我们就可以做分布式
        - 分布式应用
        - 分布式静态资源
        - 分布式数据和存储
        - 分布式计算(hadoop)

### LVS基础

#### LB集群的实现,负载均衡

- 硬件:
    - F5:BIG-IP;有时候直接称为F5
    - Citrix NetScaler 思杰
    - Array
    - Redware

- 软件
    - lvs
    - haproxy
    - nginx
    - httpd
    - vanish
    - ats(apache traffic server)
    - perlbal

- 基于工作的协议层次划分:
    - 传输层: lvs, haproxy(可以模拟在tcp层)
    - 应用层: haproxy, nginx, ats, perlbal

##### lvs: linux virtual server

- lvs的作者是章文嵩,lvs是作为内核模块来工作的,所以我们可以把它编译进内核.全称叫做linux virtual server,假装自己是服务器,可以接受用户请求,实际上它并不提供服务;后端真正提供服务的叫real server;由于lvs是通过请求报文的目标IP和PORT将其转发至后端主机集群中的某一台主机(根据挑选算法),是工作在第四层网络模型上的,所有也有人把它称为四层交换(layer 4,或者四层路由).

- lvs要附着在netfilter上工作的,lvs并不工作在PREROUTING上,而是工作在INPUT上,强行改变它的流转路程

- lvs: 由两段组成,和iptables类似,ipvsadm/ipvs:
    - 第一段 ipvsadm: 工作在用户空间,让用户写规则,定义谁是集群服务,用什么算法,有多少real server;用户空间的命令行工具,用于管理集群服务: 增删改查.
    - 第二段 ipvs: 把第一段的规则仍在ipvs上,只要在ipvs上有规则,它就能提供服务,其实不管用不用,ipvs都在INPUT那里;工作于内核中netfilter INPUT钩子上.
    
- lvs支持的协议: TCP,UDP,AH,EST,AH_EST,SCTP等诸多协议

##### lvs的架构和术语
- 术语
    - 负载均衡器(调度器): Director, dispatcher(分发器), Load Balancer;
    - 真正服务器: RS(Real Server);
    - IP名称: 客户端的CIP(Client IP), 负载均衡用来接受客户端请求的VIP(virtual ip), 负载均衡器用来和真正服务器通信的IP叫DIP(Director IP), 真实服务器的IP就叫RIP1(RIP2 ...);
    
- lvs的架构类型: 调度器如何将用户请求分发给后端Real server服务器的
    1. lvs-nat: 基于多目标dnat方式工作的
    2. lvs-dr(direct routing): 直接路由
    3. lvs-tun(ip tunneling): ip隧道
    4. lvs-fullnat: 非标准类型,有特殊公用,仍属于nat的扩展

- lvs-nat: 多目标的dnat(iptables的dnat机制)
    
```
大体工作模式: 负载均衡器有两块网卡, 一块面向互联网,一块面向内部的real server(DIP和RIP都一般使用内网地址);当用户请求到达时,请求源地址是CIP, 目标地址是VIP;如果我们在INPUT那定了规则,
强行转换到了PREROUTING那,这时候源地址不变还是CIP, 目标地址就变成了RIP1的地址(内网地址)
响应报文模式: 从RIP出来的时候, 源地址是RIP1,目标地址是CIP(注意,一定是CIP);到了负载均衡器的时候,源地址就变成了VIP;
所以这里还要注意: 
1) RS和DIP都应该使用私网地址,且RS(真实服务器)的网关一定要指向负载均衡器
2) 请求和响应保温都要经由director转发,极高负载的场景中,director可能会成为系统瓶颈
3) 支持端口映射
4) RS可以使用任意操作系统
5) RS的RIP和Director的DIP必须在同一IP网络(因为RS的网关要指向Director)
```

- lvs-dr: direct routing

```
实现方式: 通过修改请求保温的目标MAC地址进行转发;
场景: RS和Director都只有一块网卡,连接到一台交换机上,客户端请求中间通过层层路由,到服务器所在的路由器R1的时候,源地址就变成了该路由器R1,而目标地址就是VIP所在的主机的MAC地址
要点: Director收到请求后会从RS中跳一个服务器RS2出来响应请求,RS2会直接响应客户端,不再经由Director;也就是说只有请求报文经由Director,响应报文是不会经过Director的;这样
就麻烦了,RS2在响应客户端时,就直接跟客户端建立通信了,响应报文的源IP必须得是VIP,但是实际响应报文并没有经由Director,所以我们就要将所有的RS都再配一个VIP,
具体过程, 当Director收到请求后,会拆开报文头部,封装一个RS的VIP对应的MAC,此时请求报文源IP是CIP,目标IP是RS的VIP,然后路由器发起广播找到MAC对应的RS,由RS来回应客户端请求.
注意事项: 
1) 保证前段路由器将目标IP为VIP的请求报文发送给Director;
    a) 只接把VIP地址和Director的MAC绑定
    b) linux 2.6.5+内核中可以修改RS主机内核的参数
2) RS的RIP可以使用私有地址,也可以使用公网地址;
3) RS和Director一定要在同一个交换机网络上(不要被路由器隔离)
4) 请求报文经由Director调度,但是响应保温一定不能经由Director;不支持端口映射
5) RS指向的网关一定要和RIP在同一网段中,但是RS的网关不能和Director
6) RS的RIP配置在物理网卡上,VIP配置在lo接口的别名上的,且要求从哪个网卡进来的报文必须还从哪个接口出去;我们的操作是从物理网卡上转发到lo网卡.
7) RS的网关一定不能指向DIP
8) RS可以是大多数的操作系统
```

- lvs-tun: IP隧道机制: 当director收到请求的时候,不修改请求报文的ip首部,而是通过在原有的ip首部之外,再封装一个ip首部.

```
1) Director可以在任何位置,VIP一定是配置在Director上的;
2) Director和各Real Server可以不在同一机房或同一地域;
3) Real Server可以放在任何位置,但是每一个Real Server的RIP必须是公网地址
当Director收到请求报文时,在原来的报文的IP首部(源地址是CIP,目标地址时VIP)外面又封装了一个首部(源地址可能是DIP,目标地址时挑出来的某一个RIP);RS收到报文拆开一开,
目标地址不是自己,按道理应该转发出去,所以这里RS应该和dr类型相似,在自己的lo接口上再配置一个VIP地址,当内核发现目标地址时自己的lo接口,于是把里面的报文也拆掉了,
然后把回应报文通过lo接口发送给客户端应用程序.

注意事项:
a) 这时候Director和RS并不需要在同一个网络内,RIP,DIP,vip全得是公网地址
b) RS的网管不能指向Director
c) 请求报文必须经由Director调度,但响应报文必须不能经由才.
d) 要求Director和各RS支持隧道协议,也就是IP首部之外再封装一个首部
e) 互联网上发送的IP报文要有一个MTU(最大传输单元)的概念,标准是1500个字节,突然间又多了一截IP报文,可能整个报文就超出了1500,然后就可能产生fragment(IP二次切片),二次切片必须
经由的设备允许切片才行,有些设备可能不允许在此切片,那么就会造成报文无法送达;我们也可以在本地主机设定报文的数量不大于1400.给外面追加的IP报文空间生出来
```
- lvs-fullnat: 能够在请求报文到达时,director通过同事修改请求报文的目标地址和源地址进行转发

```
当Director收到报文时修改报文的源地址为DIP,目标地址为选出的某个RIP,然后响应报文的源地址为RIP,目标地址为DIP,到了Director,再次修改响应报文,将源地址改为VIP,目标地址改为CIP
注意事项:
1) VIP时公网地址,RIP和DIP时私网地址,二者无需在同一网络中
2) RS接收到的请求报文源地址为DIP,因此要响应给DIP
3) 请求报文和响应报文都必须经由Director
4) 支持端口映射机制
5) RS的操作系统可以使用任意OS
```

#### lvs类型和调度方法

- http协议是无状态的协议,后来我们服务器程序为了能够追踪每一个用户,给每一个客户端发一个id号(cookie),服务器端为了能够追踪用户的行为,要为用户保存session,这样一来就使得服务器应用变成有状态.负载均衡时就不能够任意的分发了,因为协议时无状态的,因此一个用户第一次请求以后,如果我们没有使用长连接,用户端口后,再发请求,就会被识别成新用户,就有可能被调度到其他主机上去了,此前保存的session就丢失了,我们显然不能让这种情况发生;这里我们第一个要解决的问题就是session保持问题
- session保持有多种保持方案(至关重要):
	- session绑定:
		- 源地址hash机制(source ip hash):将来自于同一个用户的请求,我们不做负载均衡,始终定向于同一台Real Server,我们要自行维护一个会话追踪表,根据IP地址追踪每一个请求的客户端.这种机制我们通常称为源地址hash机制(source ip hash),力度过于粗糙
		- cookie hash: 不管你来自于哪个IP,我们在请求报文中插入一个cookie,对于这个cookie,跟http协议中的cookie可以是同一个,也可以不是同一个.就算你不是http协议,我也可以给你cookie.这样就使得,整个交互过程中,每一次客户端请求都拿着这个cookie来,cookie时进程级别的,所以就非常精细了
	- session集群:
		- session绑定有一个严重的问题:万一某个RS宕机了,那么这个主机上的session也就都随它而去了,每一个RS都能同步其他RS上的sesion,也就是说每一个RS都会有进群中所有的session,这也有问题,网络和内存中充斥着大量的session.很浪费资源.
	- session服务器
		- 我们找一个第三方的存储服务器,用来专门存储session.
- lvs scheduler:lvs调度器,其实就是一些算法,能够根据当前后台的负载,来判定下次该挑选谁了,查看当前系统支持的算法:

```
// 其实还有种算法没有列出来,就是NQ
[root@mail ~]# grep -i -A 10 'IPVS' /boot/config-2.6.32-431.el6.x86_64
# IPVS scheduler
CONFIG_IP_VS_RR=m
CONFIG_IP_VS_WRR=m
CONFIG_IP_VS_LC=m
CONFIG_IP_VS_WLC=m
CONFIG_IP_VS_LBLC=m
CONFIG_IP_VS_LBLCR=m
CONFIG_IP_VS_DH=m
CONFIG_IP_VS_SH=m
CONFIG_IP_VS_SED=m
```

- 算法大体上又分为2两种
	- 静态算法: 仅根据算法本身进行调度
		- RR: round robin,轮调
		- WRR: weighted rr,加权RR,能者多劳,权重大的
		- SH: Source Hash, 源IP地址HASH实现session保持的机制,将来源于同一个IP的请求始终调度至同一个RS
		- DH: Destination Hash, 目标地址hash,常用的方法是,不管你的IP是什么,只要你们请求的时同一个目标,就把你定到某一个固定的RS,常用于缓存服务器;还有个案例,我们公司有两个外网出口,内网的所有客户端都要通过这俩接口出去,很有可能1号出口没什么人,2号出口全是人,为了避免这种情况,我们可以做负载均衡,加个调度器,内网中无论哪些客户端访问互联网的时候由调度器,做负载均衡决定从两个出口中的哪一个出去
	- 动态方法: 根据算法及各RS的当前负载状态进行调度
		- LC
		- WLC
		- SED
		- NQ
		- LBLC
		- LBLCR
 