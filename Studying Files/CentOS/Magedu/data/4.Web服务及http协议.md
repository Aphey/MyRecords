### WEB服务和http协议
#### 基本概念
- http: HyperText Transfer Protocol;超文本传输协议;超文本是指带有超级连接的文本
- 超链接:基于某些连接在文档间实现跳转的文本,这些连接就叫超链接;
- 早期的web协议,就是实现在文档见跳转的协议而已.
- http/0.9版本: 仅纯文本(也包括超链接,这种超链接也表现为文本),有纯ASCII码组成的,html: HyperText Mark Language 开发超文本的语言.
- 浏览器:Browser客户端代理的一种
- URI: Uniform Resource Identifier 统一资源标识符,用于标记全局范围内(并不仅限于互联网)唯一资源访问路径的命名方式;统一指的是路径格式上的统一
- URL: Uniform Resource Locator 同意资源定位符,是URI的一个子集,用于描述在互联网上互联网资源的统一表示格式: protocol://HOST:PORT/PATH/TO/FILE
- web资源: 能够让客户端通过统一资源定位符访问的文件;多个资源很可能被整合成一个html文档.web资源有时候也被称为web资源.
- http方法:资源获取的方式
    - get:从服务器获取资源到本地,并用浏览器予以展示;http协议0.9版本只有这一个方法,而http协议升级到1.0之后,就引入了更多的方法:
    - POST,和get是相对应的方法,通过表单提交数据到服务器.
    - PUT, 和DELETE相对的方法,从远程服务器上获取一个文件到本地
    - DELETE , 和put对应的放发,在远程服务器上删除一个文件
    - HEAD: 只返回首部,不返回主体
- http协议1.0更大的改进是还引入了MIME的机制
    - MIME: Multipurpose Internet Mail Extension, 多用途互联网邮件扩展,能够将非文本数据在传输前重新编码为文本格式,接收方能够用相反的方式将其还原成原来的格式,还能够继续调用相应的程序来打开此文件.
    - 引入: smtp: Simple Mail Transfer Protocl,只能传输纯文本.
- 动态网页:服务器端存储的文档非html格式,而是编程语言开发的脚本(帮助理解),脚本接受参数后在服务器先运行一次,完成后,会生成html格式的文档,并把生成的文档发给客户端. flash等等只能算是动态效果.
- 一个动态网页,包含静态内容和动态内容,动态内容部分才需要运行.
- http协议1.0版本还引入了缓存的机制.
- TCP协议包含内容:
    - IP首部: Source Ip 和 Destination IP
    - TCP首部: Source Port源端口 和Destination Port
- http协议也有自己的首部(可以理解为信封):
    - 定义了基于TCP协议要获取什么文档Get
    - Host,明确获取哪个主机的资源,一定是主机,因为涉及到后面的虚拟主机
- http 报文:
    - 请求报文,语法格式:
    
        ```
        <method> <request-URL> <version>
        <headers> //http协议的首部 
        
        <entity-body> //报文主体
        
        //案例:
        GET / HTTP/1.1  // "/" 指访问的默认页面, 1.1是协议版本
        Host: www.aphey.com
        Connection: keep-alive
        ```
    
    - 响应报文,语法格式:
        
        ```
        <version> <status状态代码> <reason-phrase>   //起始行
        <headers>   // 响应报文首部
        
        <entity-body>   // 响应主体
        // status状态码:客户端请求的文档成功与否,为了让客户端尽快知道请求的文档存在与否而给出的标识符, 有5类,都是三位数字:
        1xx: 纯信息,跟我们请求的资源没什么关系,用得很少
        2xx: 成功类的状态码,请求内容成功(200: 正常响应)
        3xx: 重定向类的信息,资源存在,但是被挪到别的地方(301,永久重定向;302,临时重定向;304 not modified 内容没有发生人和改变,用缓存去吧)
        4xx: 错误类,客户端错误类信息;常见的404,请求的文件不存在
        5xx: 服务器端错误类信息,服务器内部故障
        
        // reason-phrase: 进一步解释status的意义
        // 案例:
        HTTP:/1.1 200 OK    
        X-Powered-By: PHP/5.2.17
        Vary: Accept-Encoding,Cookie,User-Agent
        Cache-Control: max-age=3, must-revalidate
        Content-Ecoding:gzip
        Content-Length: 6931
        ```    
- web服务器的主要操作:
    1. 建立连接-接受或拒绝客户端连接请求
    2. 接受请求-通过网络读取HTTP请求报文
    3. 处理请求-解析请求报文并做出相应的动作
    4. 访问资源-访问请求报文中的相关资源
    5. 构建响应-使用正确的首部生成HTTP响应报文
    6. 发送响应-向客户端发送生成的响应报文
    7. 记录日志-当已经完成的HTTP事物记录进日志文件
- 每一个资源都要单独请求的,所以有的网页打开文字先出来,图片和视频会一张一张出来.所以为了打开页面尽可能快,浏览器一般都是多线程的.
- http,tcp,三次握手,四次断开.所以如果资源多请求会很慢,所以缓存就很重要了,所以我们的浏览器都带缓存的;刷新页面意味着,无论本地缓存存不存在,我都要重新下在一下
- 为了避免下载每个资源都要三次握手,四次断开,http协议1.1版本作了改进:
    - 增强了缓存的功能
    - 引入了长连接机制:客户端从服务器端获取第一个资源以后,不断开等着继续获取后面的资源.这个机制也有弊端:资源访问完成以后,还是不断开就占用服务器资源了.当服务器的并发量大的时候,后面的服务器就很难连进来了.当然了,一般情况下如果你的服务器的并发量没有达到无与伦比的地步,使用长连接可以显著地提高服务器响应能力的; 针对这个我们可以用空闲超时控制或者控制请求次数,请求了多少次以后,对不起,后面排队去.
- web服务器的处理模型:
    - 单进程/单线程
    - 多进程/多线程:当多个用户发起请求时,服务器进程只接受客户端请求,然后生成一个跟自己一模一样的进程,然后把请求交给子进程,依次类推;访问量不是很大的时候,这个模型很有用
    - 一个进程负责多个请求,每一个被处理的请求都有状态,然后状态的改变,就引起了时间的发生,所以我们称这个为时间驱动机制;那个请求完成,再结合通知进程,就可以提高效率;但这种模型也有弊端:如果我相应请求过多的时候,系统也会忙得不可开交,于是就有了第四种模型
    - 把第二种和第三种模型结合起来,有一个总理进程Master,只负责接受请求然后分发给子进程,然后每个子进程再负责多个请求
- 常用的Clients:
    - IE
    - Firefox
    - Chrome
    - Opera
    - Safari
- 常用的Servers:
    - Apache- httpd
    - Nginx
    - IIS
    - Lighttpd
    - thttpd
- 应用程序服务器:
    - IIS
    - Tomcat开源的
    - Websphere(IBM)专门用来解析JSP的,商业的
    - Weblogic(Bea公司的,后被Oracle收购,JSP的商业版的)
    - JBoss(Redhat的有商业版和开源的,和tomcat差不多,做了另外的封装的)