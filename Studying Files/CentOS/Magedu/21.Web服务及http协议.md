### WEB服务和http协议
#### 基本概念
- 网络模型的上三层被称为:资源子网,下四层被称为通信子网
- IPv4分类:
    - A类: `1-127`
    - B类: `128-191`
    - C类: `192-223`
    - D类: `组播,224-239`
    - E类: `240-254`
- 端口`0-1023`端口已经被IANA永久地分配给众所周知的应用了,只有管理员可以使用.
    ```python
    // 比如
    22: ssh
    21: ftp
    80: http/tcp
    443: https/tcp
    ```
- 端口`1024-41951` 也是注册端口,但是要求不是特别严格,分配给某些应用使用;普通用户也可以使用.
    ```python
    11211/TCP;11211/UDP (memcached)
    3306/tcp (Mysql)
    ...
    ```
- 端口`41592-65535`: 动态端口(也叫似有端口)端口则表示客户端程序随机使用的端口,用来回应服务端的,内核随机分配给进程使用的.在xshell上可以用`ss -tan`查看; __动态端口范围的定义文件:/proc/sys/net/ipv4/ip_local_port_range;我们可以修改,但是不要调整到1023以下__
    ```python
    [root@mail tls]# ss -tan    //这个是centos6的实例
    State      Recv-Q Send-Q        Local Address:Port          Peer Address:Port
    ESTAB      0      52           192.168.88.135:22           192.168.88.45:3592(这个就是随机端口)
    ```
- http: HyperText Transfer Protocol;超文本传输协议;超文本是指带有超级连接的文本
- 超链接:基于某些连接在文档间实现跳转的文本,这些连接就叫超链接;
- 早期的web协议,就是实现在文档见跳转的协议而已.
- http/0.9版本: 仅纯文本(也包括超链接,这种超链接也表现为文本),有纯ASCII码组成的,html: HyperText Mark Language 开发超文本的语言.
- 浏览器:Browser客户端代理的一种
- URI: Uniform Resource Identifier 统一资源标识符,用于标记全局范围内(并不仅限于互联网)唯一资源访问路径的命名方式;统一指的是路径格式上的统一
- URL: Uniform Resource Locator 同意资源定位符,是URI的一个子集,用于描述在互联网上互联网资源的统一表示格式: protocol://HOST:PORT/PATH/TO/FILE
- web资源: 能够让客户端通过统一资源定位符访问的文件;多个资源很可能被整合成一个html文档.web资源有时候也被称为web资源.
- http方法:资源获取的方式
    - get:从服务器获取资源到本地,并用浏览器予以展示;http协议0.9版本只有这一个方法,而http协议升级到1.0之后,就引入了更多的方法:
    - POST,和get是相对应的方法,通过表单提交数据到服务器.
    - PUT, 和DELETE相对的方法,从远程服务器上获取一个文件到本地
    - DELETE , 和put对应的放发,在远程服务器上删除一个文件
    - HEAD: 只返回首部,不返回主体
- http协议1.0更大的改进是还引入了MIME的机制
    - MIME: Multipurpose Internet Mail Extension, 多用途互联网邮件扩展,能够将非文本数据在传输前重新编码为文本格式,接收方能够用相反的方式将其还原成原来的格式,还能够继续调用相应的程序来打开此文件.
    - 引入: smtp: Simple Mail Transfer Protocl,只能传输纯文本.
- 动态网页:服务器端存储的文档非html格式,而是编程语言开发的脚本(帮助理解),脚本接受参数后在服务器先运行一次,完成后,会生成html格式的文档,并把生成的文档发给客户端. flash等等只能算是动态效果.
- 一个动态网页,包含静态内容和动态内容,动态内容部分才需要运行.
- http协议1.0版本还引入了缓存的机制.
- TCP:Transfer Control Protocol传输控制协议,面向连接的协议,通信前需要建立虚拟链路,结束后拆除链路
    - TCP协议的特性:
        1. 建立连接:三次握手
        2. 将数据打包成段: 校验
        3. 确认,重传及超时
        4. 排序:报文打包成段之后,都是有先后顺序的,逻辑序号,通过逻辑序号指定该段数据在整个数据流中的什么位置
        5. 流量控制:防止快发将慢收挤垮掉;通过滑动窗口算法来实现,滑动窗口可以理解为可以接受报文空间的大小,并通知给发送方
        6. 拥塞控制: 防止快速发送者压垮整个网络,通过慢启动的方式:先试探性地发送一个或几个;然后再多发几个.
- socket域:标记基于不同的IP地址(IPv4,IPv6)
    - AF_INET: Address family, IPv4
    - AF_INET6: IPv6的地址家族
    - AF_UNIX: 同一主机上的不同进程间的通信,效率更高.
    - 上述三类套接字,都至少提供了两种socket: 流, 数据报
        - 流: 可靠地传递;面向连接;无报文边界
        - 数据报: 不可靠地传递;有边界;无链接
- 套接字相关的系统调用:(C程序员用的,了解即可)
    - socket(): 创建socket
    - bind(): 绑定套接字
    - listen(): 监听
    - accept(): 接收请求
    - connect(): 请求链接建立
    - write(): 发送数据
    - read(): 从缓冲中接收数据
- UDP:User Datagram Protocol,用户数据包协议,直接把数据扔到网上去,不需要建立虚拟链路
- TCP协议包含内容:
    - IP首部: Source Ip 和 Destination IP
    - TCP首部: Source Port源端口 和Destination Port
- http协议也有自己的首部(可以理解为信封):
    - 定义了基于TCP协议要获取什么文档Get
    - Host,明确获取哪个主机的资源,一定是主机,因为涉及到后面的虚拟主机
- http 报文:
    - 请求报文,语法格式:
        ```
        <method> <request-URL> <version>
        <headers> //http协议的首部

        <entity-body> //报文主体

        //案例:
        GET / HTTP/1.1  // "/" 指访问的默认页面, 1.1是协议版本
        Host: www.aphey.com
        Connection: keep-alive
        ```

    - 响应报文,语法格式:

        ```
        <version> <status状态代码> <reason-phrase>   //起始行
        <headers>   // 响应报文首部

        <entity-body>   // 响应主体
        // status状态码:客户端请求的文档成功与否,为了让客户端尽快知道请求的文档存在与否而给出的标识符, 有5类,都是三位数字:
        1xx: 纯信息,跟我们请求的资源没什么关系,用得很少
        2xx: 成功类的状态码,请求内容成功(200: 正常响应)
        3xx: 重定向类的信息,资源存在,但是被挪到别的地方(301,永久重定向;302,临时重定向;304 not modified 内容没有发生人和改变,用缓存去吧)
        4xx: 错误类,客户端错误类信息;常见的404,请求的文件不存在
        5xx: 服务器端错误类信息,服务器内部故障

        // reason-phrase: 进一步解释status的意义
        // 案例:
        HTTP:/1.1 200 OK
        X-Powered-By: PHP/5.2.17
        Vary: Accept-Encoding,Cookie,User-Agent
        Cache-Control: max-age=3, must-revalidate
        Content-Ecoding:gzip
        Content-Length: 6931
        ```
- 一次完整的http请求过程,web服务器的主要操作:
    1. 建立连接-接受或拒绝客户端连接请求
    2. 接受请求-通过网络读取HTTP请求报文
    3. 处理请求-解析请求报文并做出相应的动作
    4. 访问资源-访问请求报文中的相关资源
    5. 构建响应-使用正确的首部生成HTTP响应报文
    6. 发送响应-向客户端发送生成的响应报文
    7. 记录日志-当已经完成的HTTP事物记录进日志文件
- 每一个资源都要单独请求的,所以有的网页打开文字先出来,图片和视频会一张一张出来.所以为了打开页面尽可能快,浏览器一般都是多线程的.
- http,tcp,三次握手,四次断开.所以如果资源多请求会很慢,所以缓存就很重要了,所以我们的浏览器都带缓存的;刷新页面意味着,无论本地缓存存不存在,我都要重新下在一下
- 为了避免下载每个资源都要三次握手,四次断开,http协议1.1版本作了改进:
    - 增强了缓存的功能
    - 引入了长连接机制:客户端从服务器端获取第一个资源以后,不断开等着继续获取后面的资源.这个机制也有弊端:资源访问完成以后,还是不断开就占用服务器资源了.当服务器的并发量大的时候,后面的服务器就很难连进来了.当然了,一般情况下如果你的服务器的并发量没有达到无与伦比的地步,使用长连接可以显著地提高服务器响应能力的; 针对这个我们可以用空闲超时控制或者控制请求次数,请求了多少次以后,对不起,后面排队去.
- web服务器的处理模型:
    - 单进程/单线程
    - 多进程/多线程:当多个用户发起请求时,服务器进程只接受客户端请求,然后生成一个跟自己一模一样的进程,然后把请求交给子进程,依次类推;访问量不是很大的时候,这个模型很有用
    - 一个进程负责多个请求,每一个被处理的请求都有状态,然后状态的改变,就引起了时 间的发生,所以我们称这个为时间驱动机制;那个请求完成,再结合通知进程,就可以提高效率;但这种模型也有弊端:如果我相应请求过多的时候,系统也会忙得不可开交,于是就有了第四种模型
    - 把第二种和第三种模型结合起来,有一个总理进程Master,只负责接受请求然后分发给子进程,然后每个子进程再负责多个请求
- 常用的Clients:
    - IE
    - Firefox
    - Chrome
    - Opera
    - Safari
- 常用的Servers:
    - Apache- httpd
    - Nginx
    - IIS
    - Lighttpd
    - thttpd
- 应用程序服务器:
    - IIS
    - Tomcat开源的
    - Websphere(IBM)专门用来解析JSP的,商业的
    - Weblogic(Bea公司的,后被Oracle收购,JSP的商业版的)
    - JBoss(Redhat的有商业版和开源的,和tomcat差不多,做了另外的封装的)
- http协议: 是无状态的,stateless,服务器无法持续追踪访问者来源(比如某用户向服务器请求资源,只要一刷新,服务器就不知道你是谁了,然后只要是敏感资源,就需要你输入账号密码),后来借助 cookie机制或者url重写机制
    - cookie机制: 某客户端第一次访问服务器时, 服务器会发一些小数据(cookie)给客户端,客户端会把它保存在磁盘的某一段存储空间当中,这个cookie可以理解为这个站点对这个客户端而言的唯一的标识,每一个cookie都有它的作用范围;为了让服务器能够识别我们的客户端,客户端在第二次发起请求时 会一起把这个cookie提交给服务器
- http事务,事务就是由一次请求和一次响应组成:
    - 请求: request,请求报文有特定格式:
        ```
        request报文
            <method> <request-URL> <httpd version>
            <heders>    //首部,然后换行两次


            <entity-body> //请求的主体部分
        ```
    - 响应: respose
        ```
        response报文
            <version响应时的协议版本> <status状态吗> <reason-phrase 原因短语>
            <heders>    //响应首部,换行两次


            <entity-body> //请求的主体部分
        ```
    - 详解:
        - metod: 请求方法,标明客户端希望服务器对资源执行的动作
        ```
        GET: 从服务器获得一个资源
        HEAD: 只从服务器获取文档的响应首部
        POST: 向服务器发送需要服务器处理的数据,这些数据会放在请求的主题部分
        PUT: 跟GET相反,将请求的主体部分存储在服务器上,比较危险,服务器不能随便让人上传数据
        DELETE: 请求删除服务器上的通过URL指定的文档
        TRACE: 追踪请求到达服务器中间经过的代理服务器
        OPTIONS: 可以请求服务器返回对指定资源支持使用的请求方法
        ```
        - version: 格式 HTTP/<major>.<minor>
        - status: 三位数字,如200,301,302,404,502表示响应状态码,用来描述请求过程中发生的情况
        ```
        // status状态码:客户端请求的文档成功与否,为了让客户端尽快知道请求的文档存在与否而给出的标识符, 有5类,都是三位数字:
        1xx: 常用的是100-101,信息提示,跟我们请求的资源没什么关系,用得很少
        2xx: 200-206,成功类的状态码,请求内容成功(200: 正常响应)
        3xx: 重定向类的信息,资源存在,但是被挪到别的地方(301,永久重定向;302,临时重定向;304 not modified 内容没有发生人和改变,用缓存去吧)
        4xx: 400-415,错误类,客户端错误类信息;常见的404,请求的文件不存在
        5xx: 服务器端错误类信息,服务器内部故障

        // 常用的状态码:
        200: 成功, 请求的所有数据通过响应报文的entity-body部分发送,OK
        301: 永久重定向,请求的URL指向的资源已经被永久删除,单在响应报文中通过首部Location指明了资源现在所处的新位置 moved permanently
        302: 与301相似,不过响应报文在响应报文中通过Location首部,指明了资源现在所处的临时新位置, Found
        304: 客户端发出了条件式请求,但服务器上的资源未曾发生改变,则通过此响应状态码告诉客户端, Not Modified
        401: 需要输入账号和密码认证方可访问资源, Unauthorized
        403: 请求被禁止, Forbidden
        404: 服务器无法找到客户端请求的资源, Not Found
        500: 服务器内部错误, Internal Server Error
        502: 代理服务器从后端服务器收到一条未响应, Bad Gateway
        ```
        - header: 每个请求或响应报文可以包含任意个首部,每一个首部都有首部名称,后面跟一个冒号,然后跟上一个可选空格,接着是一个值;
        ```
        //首部的分类:
            通用首部: 既可以用在请求首部中,又可以用在响应首部中常用的
                Date: 报文的创建时间
                Connection: 连接方式或者链接状态,如keep-alive 或者close
                Via: 显示报文经过的中间节点
                Cache-Control: 控制缓存
                Pragma: 也是和缓存相关
            请求首部
                Accept: 通知服务器,我这边能够接受的媒体类型
                Accept-Charset: 允许接受的字符集
                Accept-Encoding: 接受的编码格式,如gzip
                Accept-Language: 接受的语言
                Client-IP: 客户端的IP
                Host: 请求的服务器名称和端口号
                Referer: 包含当前正在请求的资源的上一级资源,比如,我从"www.google.com/serch"页面跳转过来的.这里的referer就是google的站点
                User-Agent: 客户端代理,其实就是浏览器
                条件式请求首部:
                Expect：我期望服务器发什么样的信息
                If-Modified-Since: 自从某某时间后，请求的资源是否发生过修改
                If-Notmodified-Since: 自从某某时间后，请求的资源是否没有发生过修改
                If-None-Match: 本地缓存中存储的文档的Etag标签是否与服务器文档中的Etag 是否不匹配
                If-Matach: 本地缓存中存储的文档的Etag标签是否与服务器文档中的Etag 是否匹配
                安全请求首部：
                Authorization: 向服务器发送认证信息，如账号密码
                Cookie: 客户端想服务器发送cookie
                Cookie2: cookie2 版本
                代理请求首部：
                Proxy-Authorization: 向代理服务器认证
            响应首部
                信息性首部：
                Age: 响应持续时长
                Sever: 服务器程序软件名称和版本,Apache/Nginx等等
                协商首部: 某自愿有多种表示方法时使用,比如某个页面有多种语言
                Accept-Ranges: 服务器可接受的请求范围类型
                Vary: 服务器查看的其他首部列表
                安全响应首部:
                Set-Cookie: 向客户端设置Cookie
                Set-Cookie2: 向客户端设置第二版的Cookie
                WWW-Authenticate: 来自服务器的对客户端的质询认证表单
            实体首部: 用来标识实体自己的相关信息
                Allow: 列出对此实体可使用的请求方法
                Location: 告诉客户端真正实体位于何处,一般重定向时使用
                Content-Encoding: 内容的编码格式
                Content-Language: 内容的语言
                Content-Length: 主体的长度
                Content-Type: 主体的对象类型
                缓存相关的:
                Etag: 实体的扩展标签;
                Expires: 实体的过期时间
                Last-Modified: 上一次修改时间
            扩展首部
        ```
        - entity-body:实体部分,也就是有用的数据块,请求时附加的数据或响应时附加的数据
    - 协议查看或分析的工具: tcpdump, tshark, wireshark
