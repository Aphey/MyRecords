1. 启动ECP： 要先 装JAVA，并开启TOMCAT
2. 开启kodexplorer 和 禅道，要先关闭服务器防火墙
  systemctl stop firewalld.service
3. -rw-r--r-x（drw-r--r-x)
   分解：-（-表示文件，d表示文件夹） rw-(owner权限，）r--（Group权限）r-x（Others权限）【r=4;w=2;x=1,7（4+2+1)表示读写执行都有】
4. 删除文件命令  rm -rf XX：
  -r表示向下递归，不管多少级目录，一并删除
  -f表示直接强行删除，不做任何提示
5. ip a
    查看本机IP地址
6. ip ad li
    查看IP地址是否生效
7. ping -c 4 192.168.0.32
    向192.168.0.32 ping 4次,然后自动停止
8. iptables -vnL
    查看iptables是否打开
9. 使用setup 图形界面
    先安装setuptools #yum install setuptool
    然后输入setup #setup
10. 修改IP地址
    vi /etc/sysconfig/network-scripts/ifcfg-eth0
    将其中的INTERFACE_NAME 替换为实际接口名称.如 eth0 或者 ens256
            修改配置文件 /etc/sysconfig/network-scripts/ifcfg-接口名称,
            [root@controller ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736 # eno16777736是我电脑网络接口的名字,根据电脑改变 #
        包含如下内容:
            不要修改 HWADDR和 UUID关键字内容.
               Advanced Micro Devices [AMD] 79c970 [PCnet32 LANCE] —————–网卡名称
                          DEVICE=eth0 ——————–定义第几块网卡
                          TYPE=Ethernet
                          BOOTPROTO=dhcp /*static:静态IP ;none:无,不指定;dhcp:动态IP*/
                          IPADDR=192.168.0.33 /*当BOOTPROTO=static时,这里可以设置为自己想要的IP地址*/
                          NETMASK=255.255.255.0 /*当BOOTPROTO=static时,这里添加以下子网掩码*/
                          HWADDR=00:0C:29:82:E8:F4 ————这个是MAC地址
                          DEFROUTE=yes
                          IPV4_FAILURE_FATAL=no
                          IPV6_AUTOCONF=yes
                          IPV6_DEFROUTE=yes
                          IPV6_FAILURE_FATAL=no
                          NAME=eno16777736
                          UUID=fcd58748-372a-44f9-bbf1-9da9fc001bb2
                          DEVICE=eno16777736
                          ONBOOT=yes   /*yes:开机启动*/
                          PEERDNS=yes
                          PEERROUTES=yes
                          IPV6_PEERDNS=yes
                          IPV6_PEERROUTES=yes
                          IPV6_PRIVACY=no
        把网络服务重启一下# service network restarte

11. 然之默认的数据库账号为root, 密码为空
    然之备份跨服务器还原时,得给bakup文件夹 777 权限
    然之的数据库连接参数在ranzhi/config/my.php内
    phpmyadmin的连接参数需要相应的修改，蝉知的数据库连接参数在chanzhi/system/config/my.php内

2015年12月10日Linux学习笔记

Linux 分区类型

        主分区:最多可以分4个主分区,且必须有一个作为扩展分区,分区名规则:1-4只能给主分区和扩展分区,逻辑分区只能从5开始,
        且不管有几个主分区, 逻辑分区都从5开始.
        扩展分区只能包含逻辑分区,扩展分区是一个抽象的笼统的名称.

        硬件文件名:
        IDE硬盘    /dev/hd (a-d)
        SCSI硬盘/SATA硬盘  /dev/sd(a-d)
        光驱      /dev/cdrom 或者 /dev/sr0

    Windows: 硬盘一般都是分区→格式化→分配盘符(Window 叫盘符,Linux叫挂载点) 然后可以使用
    Linux: 分区→格式化→为分区建立硬件名→分配挂载点(Windows里的盘符) 然后可以使用

    Linux 挂载点分配:
                必须分区:/  (根分区)
                        swap(交换分区,一般为内存的两倍,但是不超过2G,相当于windows的虚拟内存)
                        swap 是没有盘符,也不需要盘符
                推荐分区:/boot 一般200M就可以了用来放置启动配置文件 [一定是sdx1]
                在硬盘空间分配方面,可以给根分区单独分配一个磁盘空间,也可以给根目录的子目录分独立的磁盘空间
                分区顺序: 1. /boot  200M 2. SWAP  一般为内存两倍,但是不超过2G 3.剩余的全部留给根目录

    安装日志:
        /root/install.log 存储了安装在系统中软件及其版本的信息
        /root/install.log.syslog 存储了安装过程中留下的事件信息
        /root/anaconda-ks.cfg 以kickstart 配置文件的格式记录安装过程中设置的选项信息



2015年12月11日Linux学习笔记

    一、虚拟机几种网络连接方式解释
        1.桥接:虚拟机使用物理机的真实网卡
            优点:配置简单,还可以和物理机所在局域网内的其他计算机进行通信
            缺点:占用网段的一个IP地址,容易造成IP冲突
        2.NAT:一般是通过VMwarenet8跟真实机进行通信,同时还能访问互联网
        3.Host-only:通过VMwarenet1与主机通信,只能与主机通信,不能访问互联网
        2与3 只能和 物理机通讯,无法和局域网内的其他机器进行通信

    二、给Linux机器分配一个IP地址
        1.ifconfig eth0(第一块网卡名,第二块为eth1,依次类推) 192.168.1.X
        注意,Linux命令是写入数据,只能暂时给机器分配一个IP地址,重启后会失效;只有修改配置,才能永久生效
        2. df
        查看分区使用率
    三、linux所有内容都是以文件格式保存,包括硬件
    四、Linux没有扩展名，且不依靠扩展名区分文件类型
        文件列表颜色表示的意思；
        绿色：可执行文件
        蓝色：快捷方式，软连接
    五、Linux目录的用途
        1./bin/ 存放系统命令的目录,普通用户和超级用户都可以执行,不过放在/bin/目录下的命令在单用户模式(相当于WINDOWS的安全模式)
        下也可以执行.
        2./sbin/ 保存和系统环境设置相关的命令,只有超级用户可以使用这些命令进行系统环境的设置,但是有些命令可以允许普通用户查看.
        3./usr/bin/ usr 是unix software resource的缩写,是存放系统命令的目录,普通用户和超级用户都可以执行,这些命令和系统启动无关,
        在单用户模式下不能执行.
        4./usr/sbin/ 存放根文件系统不必要的系统管理命令,例如多数服务器和程序,只有超级用户可以使用
        5./boot/ 系统启动目录,保存系统启动相关的文件,如内核文件和系统启动引导程序(grub)文件等.
        6./dev/ 设备文件保存位置,linux中所有内容都以文件形式保存,包括硬件.
        7./etc/ 配置文件保存位置,系统内所有采用默认安装方式(rpm)的服务的配置文件全都保存在这个目录中.如用户账号和密码;服务启动脚本;
          常用服务的配置文件等
        8./home/ 普通用户的家目录,建立每个用户时,每个用户都要有一个默认的登录位置,这个位置就是这个用户的家目录,所有用户的家目录就是在/home
        文件夹下建一个和用户名一样的目录,如用户user1的家目录就是/home/user1/
        9./lib/ 系统调用的函数库的保存位置
        10. /lost+found/当系统意外崩溃或者机器意外关机而产生的一些碎片就放在这里,在系统启动的过程中fsck工具会检查这里,并修复已经损坏
        的系统文件.这个目录只在每个分区中出现,如/lost+found/就是根目录的备份恢复目录,/boot/lost+found/就是/boot分区的备份恢复目录
        11./media/ 挂载目录,系统建议是用来挂载媒体设备的,如软盘和光驱
        12./mnt/ 挂载目录,早期linux中只有这一个挂载目录,并没有细分,现在这个目录系统建议挂载额外设备,如U盘,移动硬盘,和其他操作系统分区
        13./misc/ 挂载目录,系统建议用来挂载NFC服务的共享目录,
        /*系统虽然准备了 /media/、/mnt/、/misc/三个默认挂载目录,但到底在哪个目录中挂载什么设备,都是由管理员自由决定的,如超哥的习惯是
        只挂载一个/mnt/目录,然后在/mnt/下建立不同目录挂载不同的设备,如/mnt/cdrom/,/mnt/usb/
        */
        14./opt/ 第三方安装软件的保存位置,这个目录就是放置其和安装其他软件的位置.
        /* 超哥手工安装的源码包都是放置在这个目录下,超哥更习惯把软件放到/usr/local/中
        */
        15./proc/ 虚拟文件系统,该目录中的文件并不保存到硬盘当中,而是保存在内存当中,主要保存系统的内核,进程,外部设备状态和网络状态灯,
        如/proc/cpuinfo是保存cpu信息/proc/device 是保存设备驱动列表的,/proc/filesystem 是保存文件列表的,
        /proc/net是保存网络协议信息的.
        16./sys/ 虚拟文件系统,和/proc一样,是保存在内存当中的,主要保存内核相关信息.
        17./root/ 超级用户的家目录,普通用户的家目录在/home/下,超级用户的家目录在"/"下
        18./srv/ 服务数据目录,一些系统服务启动后,可以在这个目录中保存所需要的数据
        19./tmp/ 临时目录,系统存放临时文件的目录,该目录下所有用户都可以访问和写入,建议此目录中不保存重要数据,最好每次开机都把此目录清空
        20./usr/ 系统软件资源目录,unix software resource的缩写,和user没有关系,所以此目录不是存放用户数据而是存放系统软件资源的目录,
        系统中安装的软件大多数保存在这里.此目录功能相当于windows系统 C:\windows 文件夹
        21./var/ 动态数据保存位置,主要保存缓存,日志,和软件运行所产生的的文件,其实就是日志,邮件,数据库
    六、服务器相关的注意事项:
        1.远程服务器不允许关机,只能重启
        2.重启时,应该关闭服务
        3.在服务器访问高峰,不能运行高负载命令
        4.远程配置防火墙的时候,不要把自己踢出服务器
        5.指定合理的密码规范和定期更新
        6.合理分配权限
        7.定期备份重要数据和日志

2015年12月14日Linux学习笔记
    常用命令详解
    一、文件与目录处理命令: ls
        命令格式:ls [-选项] [参数] /*参数表示命令的操作对象;中括号表示可选,可有可无*/;
             例:ls -la /etc
           讲解:列出 /etc 目录下所有文件包括影藏文件的详细列表
        说明:1)个别命令的使用不遵循这个格式
            2)当有多个选项时,可以写在一起如 -la = -l -a
            3)简化选项与完整选项: -a = --all
        1.命令名称: ls ;    英文全称:list ;     功能描述:显示目录文件;
         语法: ls [-ald] [文件目录名称].
         选项详解: -a (all) 显示所有文件,包括隐藏文件(隐藏文件是以.开头)
                  -l (long) 长格式,显示文件和目录的详细信息,[lh]则用M,K 来显示文件大小信息h 表human,人性化的
                  -d (directory) 查看目录属性
         PS:隐藏文件的作用是,告诉用户,这些文件是系统文件,不是必须执行的话最好别动,在linuxOS中隐藏文件的方法是在文件名前面加"."
         衍生的内容: drwxr-xr-x. 93 root root 8192 12月 14 16:30 /etc
                  d(表类型,d是文件夹,-是文件,l是软连接)rwx(owner的权限,r是读,w是写,x是执行)r-x(group的权限)r-x(others的权限)

         ls(list)

         功能说明：列出目录内容。

         语　　法：ls [-1aAbBcCdDfFgGhHiklLmnNopqQrRsStuUvxX][-I <范本样式>][-T <跳格字数>][-w <每列字符数>]
         [--block-size=<区块大小>][--color=<使用时机>][--format=<列表格式>][--full-time][--help][--indicator-style=<标注样式>]
         [--quoting-style=<引号样式>][--show-control-chars][--sort=<排序方式>][--time=<时间戳记>][--version][文件或目录...]

         补充说明：执行ls指令可列出目录的内容，包括文件和子目录的名称。

         参　　数：
           -1   每列仅显示一个文件或目录名称。
           -a或--all   下所有文件和目录。
           -A或--almost-all   显示所有文件和目录，但不显示现行目录和上层目录。
           -b或--escape   显示脱离字符。
           -B或--ignore-backups   忽略备份文件和目录。
           -c   以更改时间排序，显示文件和目录。
           -C   以又上至下，从左到右的直行方式显示文件和目录名称。
           -d或--directory   显示目录名称而非其内容。
           -D或--dired   用Emacs的模式产生文件和目录列表。
           -f   此参数的效果和同时指定"aU"参数相同，并关闭"lst"参数的效果。
           -F或--classify   在执行文件，目录，Socket，符号连接，管道名称后面，各自加上"*","/","=","@","|"号。
           -g   次参数将忽略不予处理。
           -G或--no-group   不显示群组名称。
           -h或--human-readable   用"K","M","G"来显示文件和目录的大小。
           -H或--si   此参数的效果和指定"-h"参数类似，但计算单位是1000Bytes而非1024Bytes。
           -i或--inode   显示文件和目录的inode编号。
           -I<范本样式>或--ignore=<范本样式>   不显示符合范本样式的文件或目录名称。
           -k或--kilobytes   此参数的效果和指定"block-size=1024"参数相同。
           -l   使用详细格式列表。
           -L或--dereference   如遇到性质为符号连接的文件或目录，直接列出该连接所指向的原始文件或目录。
           -m   用","号区隔每个文件和目录的名称。
           -n或--numeric-uid-gid   以用户识别码和群组识别码替代其名称。
           -N或--literal   直接列出文件和目录名称，包括控制字符。
           -o   此参数的效果和指定"-l" 参数类似，但不列出群组名称或识别码。
           -p或--file-type   此参数的效果和指定"-F"参数类似，但不会在执行文件名称后面加上"*"号。
           -q或--hide-control-chars   用"?"号取代控制字符，列出文件和目录名称。
           -Q或--quote-name   把文件和目录名称以""号标示起来。
           -r或--reverse   反向排序。
           -R或--recursive   递归处理，将指定目录下的所有文件及子目录一并处理。
           -s或--size   显示文件和目录的大小，以区块为单位。
           -S   用文件和目录的大小排序。
           -t   用文件和目录的更改时间排序。
           -T<跳格字符>或--tabsize=<跳格字数>   设置跳格字符所对应的空白字符数。
           -u   以最后存取时间排序，显示文件和目录。
           -U   列出文件和目录名称时不予排序。
           -v   文件和目录的名称列表以版本进行排序。
           -w<每列字符数>或--width=<每列字符数>   设置每列的最大字符数。
           -x   以从左到右，由上至下的横列方式显示文件和目录名称。
           -X   以文件和目录的最后一个扩展名排序。
           --block-size=<区块大小>   指定存放文件的区块大小。
           --color=<列表格式>   培植文件和目录的列表格式。
           --full-time   列出完整的日期与时间。
           --help   在线帮助。
           --indicator-style=<标注样式>   在文件和目录等名称后面加上标注，易于辨识该名称所属的类型。
           --quoting-syte=<引号样式>   把文件和目录名称以指定的引号样式标示起来。
           --show-control-chars   在文件和目录列表时，使用控制字符。
           --sort=<排序方式>   配置文件和目录列表的排序方式。
           --time=<时间戳记>   用指定的时间戳记取代更改时间。
           --version   显示版本信息。



        2.命令名称: mkdir ;    英文全称:make directories ;     功能描述:创建新目录;
         语法: mkdir [-p] [文件目录名称].
         选项详解: -p (parents) 递归创建,即创建新目录的同时,还为其创建子目录,
         Example: mkdir -p /tmp/Japan/boduo  表示在tmp下创建一个 Japan目录,并在Japan中创建一个boduo的子目录
         mkdir命令还可以同时创建多个目录,这些目录用空格隔开,Example: mkdir /tmp/japan /tmp/czech

         mkdir(make directories)

         功能说明：建立目录

         语　　法：mkdir [-p][--help][--version][-m <目录属性>][目录名称]

         补充说明：mkdir可建立目录并同时设置目录的权限。

         参　　数：
           -m<目录属性>或--mode<目录属性>   建立目录时同时设置目录的权限。
           -p或--parents   若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录。
           --help   显示帮助。
           --verbose   执行时显示详细的信息。
           --version   显示版本信息。



        3.命令名称: cd ;    英文全称:change directories ;     功能描述:切换目录;
         语法: cd [文件目录名称].
         范例:cd /tmp/japan 切换到指定目录    cd ../ 切换到上一级目录   ./ 当前目录

         cd(change directory)

         功能说明：切换目录。

         语　　法：cd [目的目录]

         补充说明：cd指令可让用户在不同的目录间切换，但该用户必须拥有足够的权限进入目的目录。



        4.命令名称: pwd ;    英文全称:print working directories ;     功能描述:显示当前工作目录;
         语法: pwd

         pwd(print working directory)

         功能说明：显示工作目录。

         语　　法：pwd [--help][--version]

         补充说明：执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。

         参　　数：
           --help   在线帮助。
           --version   显示版本信息。



        5.命令名称: rmdir ;    英文全称:remove directories ;     功能描述:删除空的目录;
         语法: rmdir [目录名称] 范例:rmdir /tmp/japan/boduo

         rmdir(remove directory)

         功能说明：删除目录。

         语　　法：rmdir [-p][--help][--ignore-fail-on-non-empty][--verbose][--version][目录...]

         补充说明：当有空目录要删除时，可使用rmdir指令。

         参　　数：
           -p或--parents   删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除。
           --help   在线帮助。
           --ignore-fail-on-non-empty   忽略非空目录的错误信息。
           --verbose   显示指令执行过程。
           --version   显示版本信息。




        6.命令名称: cp ;    英文全称:copy ;     功能描述:复制文件或目录;
         语法: cp [原文件或目录] [目标目录]
         选项详解: -r (recursive:英[rɪ'kɜːsɪv] 美[rɪ'kɝsɪv]adj. [数] 递归的；循环的) 目录
                  -p (property:英['prɒpətɪ] 美['prɑpɚti] n. 性质，性能；财产；所有权) 保留原目录或文件的属性
         范例: cp -r /tmp/japan/boduo /root 解释:把/tmp/japan下的boduo文件夹复制到/root下
              cp -rp /tmp/japan /tmp/czech /root 解释:把/tmp下的japan和czech两个文件夹复制到/root下,并保留这两文件夹的属性
              cp -r /tmp/japan/boduo /root/nvshen 解释:把/tmp/japan下的boduo文件夹复制到/root下并改名为nvshen


         cp(copy)


         功能说明：复制文件或目录。

         语　　法：cp [-abdfilpPrRsuvx][-S <备份字尾字符串>][-V <备份方式>][--help][--spares=<使用时机>][--version][源文件或目录][目标文件或目录] [目的目录]

         补充说明：cp指令用在复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，而最后的目的地并非是一个已存在的目录，则会出现错误信息。

         参　　数：
         　-a或--archive 　此参数的效果和同时指定"-dpR"参数相同。
         　-b或--backup 　删除，覆盖目标文件之前的备份，备份文件会在字尾加上一个备份字符串。
         　-d或--no-dereference 　当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录。
         　-f或--force 　强行复制文件或目录，不论目标文件或目录是否已存在。
         　-i或--interactive 　覆盖既有文件之前先询问用户。
         　-l或--link 　对源文件建立硬连接，而非复制文件。
         　-p或--preserve 　保留源文件或目录的属性。
         　-P或--parents 　保留源文件或目录的路径。
         　-r 　递归处理，将指定目录下的文件与子目录一并处理。
         　-R或--recursive 　递归处理，将指定目录下的所有文件与子目录一并处理。
         　-s或--symbolic-link 　对源文件建立符号连接，而非复制文件。
         　-S<备份字尾字符串>或--suffix=<备份字尾字符串> 　用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的备份字尾字符串是符号"~"。
         　-u或--update 　使用这项参数后只会在源文件的更改时间较目标文件更新时或是　名称相互对应的目标文件并不存在，才复制文件。
         　-v或--verbose 　显示指令执行过程。
         　-V<备份方式>或--version-control=<备份方式> 　用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这字符串不仅可用"-S"参数变更，当使用"-V"参数指定不同备份方式时，也会产生不同字尾的备份字串。
         　-x或--one-file-system 　复制的文件或目录存放的文件系统，必须与cp指令执行时所处的文件系统相同，否则不予复制。
         　--help 　在线帮助。
         　--sparse=<使用时机> 　设置保存稀疏文件的时机。
         　--version 　显示版本信息。




        7.命令名称: mv ;    英文全称:move ;     功能描述:剪切文件,重命名文件;
         语法: mv [原文件或目录] [目标目录]
         范例:mv /tmp/japan /root(/riben) 把/tmp下的japan文件夹剪切到/root下(并改名为riben)
             mv /tmp/japan /tmp/riben  在/tmp下把japan文件夹改名为riben

         mv(move)

         功能说明：移动或更名现有的文件或目录。

         语　　法：mv [-bfiuv][--help][--version][-S <附加字尾>][-V <方法>][源文件或目录][目标文件或目录]

         补充说明：mv可移动文件或目录，或是更改文件或目录的名称。

         参　　数：
         　-b或--backup 　若需覆盖文件，则覆盖前先行备份。
         　-f或--force 　若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文　件或目录。
         　-i或--interactive 　覆盖前先行询问用户。
         　-S<附加字尾>或
         　--suffix=<附加字尾> 　与-b参数一并使用，可指定备份文件的所要附加的字尾。
         　-u或--update 　在移动或更改文件名时，若目标文件已存在，且其文件日期比源文件新，则不覆盖目标文件。
         　-v或--verbose 　执行时显示详细的信息。
         　-V=<方法>或
         　--version-control=<方法> 　与-b参数一并使用，可指定备份的方法。
         　--help 　显示帮助。
         　--version 　显示版本信息。



        8.命令名称: rm ;    英文全称:remove ;     功能描述:删除文件或者目录;
         语法: rm [文件或目录]
         选项:-r(recursive)  -f(force)
         范例:rm -rf /tmp/japan 强制(不需要确认)删掉/tmp下的japan文件夹

         rm(remove)

         功能说明：删除文件或目录。

         语　　法：rm [-dfirv][--help][--version][文件或目录...]

         补充说明：执行rm指令可删除文件或目录，如欲删除目录必须加上参数"-r"，否则预设仅会删除文件。
         参　　数：
         　-d或--directory 　直接把欲删除的目录的硬连接数据删成0，删除该目录。
         　-f或--force 　强制删除文件或目录。
         　-i或--interactive 　删除既有文件或目录之前先询问用户。
         　-r或-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
         　-v或--verbose 　显示指令执行过程。
         　--help 　在线帮助。
         　--version 　显示版本信息。



2015年12月17日Linux学习笔记
    文件处理命令:
        1.命令名称: touch ;     功能描述:创建空文件
         语法:touch [文件名]
         范例:touch /tmp/japanlovestory.list
         PS:要创建一个文件名内带空格的文件方法: 把文件名标上双引号, 例: touch /tmp/"program files"

         touch

         功能说明：改变文件或目录时间。

         语　　法：touch [-acfm][-d <日期时间>][-r <参考文件或目录>][-t <日期时间>][--help]　　 [--version][文件或目录...] 或 touch [-acfm][--help][--version][日期时间][文件或目录...]

         补充说明：使用touch指令可更改文件或目录的日期时间，包括存取时间和更改时间。

         参　　数：
         　-a或--time=atime或--time=access或--time=use 　只更改存取时间。
         　-c或--no-create 　不建立任何文件。
         　-d<时间日期> 　使用指定的日期时间，而非现在的时间。
         　-f 　此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。
         　-m或--time=mtime或--time=modify 　只更改变动时间。
         　-r<参考文件或目录> 　把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同。
         　-t<日期时间> 　使用指定的日期时间，而非现在的时间。
         　--help 　在线帮助。
         　--version 　显示版本信息。




        2.命令名称:cat ;        功能描述:显示文件内容
         语法:cat [文件名]
         选项:-n (numbers) 显示行号
         范例:cat /etc/services
             cat -n /etc/services
         PS:tac 命令为倒叙显示文件内容,且不带-n选项

         cat


         使用权限：所有使用者
         使用方式：cat [-AbeEnstTuv] [--help] [--version] fileName
         说明：把档案串连接后传到基本输出（萤幕或加 > fileName 到另一个档案）
         参数：
         -n 或 --number 由 1 开始对所有输出的行数编号
         -b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号
         -s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行
         -v 或 --show-nonprinting
         范例：
         cat -n textfile1 > textfile2 把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里
         cat -b textfile1 textfile2 >> textfile3 把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。



        3.命令名称: more ;      功能描述:分页显示文件内容
         语法:more [文件名]
             空格或者f键翻页,回车键翻行,q键退出
        4.命令名称:less ;       功能描述:分页显示文件内容,支持往回翻页和翻行
         语法:less [文件名]
             pageup往上翻页, 上标键往上翻行; 还可以用/+关键字进行搜索,在搜索完成后按n 跳转到下一个匹配到的关键字
        5.命令名称:head ;       功能描述:显示文件的前几行
         语法:head [文件名]  /*默认显示文件的前10行*/
         选项: -n (numbers) 选择显示的行数
         示例: head -n 20 /etc/services /*显示services文件的前20行*/
        6.命令名称:tail ;       功能描述:显示文件的最末几行
         语法:tail [文件名]  /*默认显示文件的后10行*/
         选项: -n (numbers) 选择显示的行数
              -f (follow) 动态显示文件末尾的内容,如日志什么的


2015年12月17日Linux学习笔记
    ln(link)

    功能说明：连接文件或目录。

    语　　法：ln [-bdfinsv][-S <字尾备份字符串>][-V <备份方式>][--help][--version][源文件或目录][目标文件或目录] 或
    ln [-bdfinsv][-S <字尾备份字符串>][-V <备份方式>][--help][--version][源文件或目录...][目的目录]

    补充说明：ln指令用在连接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制
    到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。

    参　　数：
    　-b或--backup 　删除，覆盖目标文件之前的备份。
    　-d或-F或--directory 　建立目录的硬连接。
    　-f或--force 　强行建立文件或目录的连接，不论文件或目录是否存在。
    　-i或--interactive 　覆盖既有文件之前先询问用户。
    　-n或--no-dereference 　把符号连接的目的目录视为一般文件。
    　-s或--symbolic 　对源文件建立符号连接，而非硬连接。
        软连接相当于windows的快捷方式;所有软连接的权限均为lrwxrwxrwx;软连接文件都很小;软连接都有箭头指向源文件
        硬链接则表示和源文件同步更新,相当于保留属性复制+同步更新!
    　-S<字尾备份字符串>或--suffix=<字尾备份字符串> 　用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，预设的字尾备份字符串
     是符号"~"，您可通过"-S"参数来改变它。
    　-v或--verbose 　显示指令执行过程。
    　-V<备份方式>或--version-control=<备份方式> 　用"-b"参数备份目标文件后，备份文件的字尾会被加上一个备份字符串，这个字符串不仅可用
     "-S"参数变更，当使用"-V"参数<备份方式>指定不同备份方式时，也会产生不同字尾的备份字符串。
    　--help 　在线帮助。
    　--version 　显示版本信息。
     PS:一个文件只对应一个i节点,但是一个i节点可以对应几个文件(如硬链接),这些文件相对独立,删除一个,其他的不受影响,依然存在.
       硬链接不能跨分区使用,软连接可以;硬链接不能针对目录使用,软连接可以

    chmod(change mode)

    功能说明：变更文件或目录的权限。

    语　　法：chmod [-cfRv][--help][--version][<权限范围>+/-/=<权限设置...>][文件或目录...] 或
    chmod [-cfRv][--help][--version][数字代号][文件或目录...] 或
    chmod [-cfRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]

            chmod [{ugoa}{+-=}{rwx}][文件名或者目录]
                  [mode=421][文件名或者目录]

    补充说明：在UNIX系统家族里，文件或目录权限的控制分别以读取，写入，执行3种一般权限来区分，另有3种特殊权限可供运用，
    再搭配拥有者与所属群组管理权限范围。您可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。
    符号连接的权限无法变更，如果您对符号连接修改权限，其改变会作用在被连接的原始文件。权限范围的表示法如下：
    　u：User，即文件或目录的拥有者。
    　g：Group，即文件或目录的所属群组。
    　o：Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围。
    　a：All，即全部的用户，包含拥有者，所属群组以及其他用户。

    　有关权限代号的部分，列表于下：
    　r：读取权限，数字代号为"4"。         对文件:可以查看文件内容   对目录:可以列出目录中的内容
    　w：写入权限，数字代号为"2"。         对文件: 可以修改文件内容  对目录:可以在目录中创建,删除文件
    　x：执行或切换权限，数字代号为"1"。    对文件: 可以执行文件      对目录:可以进入目录
    　-：不具任何权限，数字代号为"0"。
    　s：特殊?b>功能说明：变更文件或目录的权限。

    参　　数：
    　-c或--changes 　效果类似"-v"参数，但仅回报更改的部分。
    　-f或--quiet或--silent 　不显示错误信息。
    　-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
    　-v或--verbose 　显示指令执行过程。
    　--help 　在线帮助。
    　--reference=<参考文件或目录> 　把指定文件或目录的权限全部设成和参考文件或目录的权限相同
    　--version 　显示版本信息。
    　<权限范围>+<权限设置> 　开启权限范围的文件或目录的该项权限设置。
    　<权限范围>-<权限设置> 　关闭权限范围的文件或目录的该项权限设置。
    　<权限范围>=<权限设置> 　指定权限范围的文件或目录的该项权限设置。

     命令名称: useradd linzhiling ;      功能描述:添加一个linzhiling用户

     命令名称: passwd linzhiling ;      功能描述:为linzhiling用户设置密码

     命令名称: groupadd linzhiling ;      功能描述:添加一个linzhiling用户组

     chown(change owner)

     功能说明：变更文件或目录的拥有者或所属群组。PS:只有root用户可以进行此操作

     语　　法：chown [-cfhRv][--dereference][--help][--version][拥有者.<所属群组>][文件或目录..]
     或chown [-chfRv][--dereference][--help][--version][.所属群组][文件或目录... ...]
     或chown [-cfhRv][--dereference][--help][--reference=<参考文件或目录>][--version][文件或目录...]

     补充说明：在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chown指令去变更文件与目录的拥有者或所属群组，
     设置方式采用用户名称或用户识别码皆可，设置群组则用群组名称或群组识别码。

     参　　数：
     　-c或--changes 　效果类似"-v"参数，但仅回报更改的部分。
     　-f或--quite或--silent 　不显示错误信息。
     　-h或--no-dereference 　之对符号连接的文件作修改，而不更动其他任何相关文件。
     　-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
     　-v或--version 　显示指令执行过程。
     　--dereference 　效果和"-h"参数相同。
     　--help 　在线帮助。
     　--reference=<参考文件或目录> 　把指定文件或目录的拥有者与所属群组全部设成和参考文件或目　录的拥有者与所属群组相同。
     　--version 　显示版本信息。

chgrp(change group)

功能说明：变更文件或目录的所属群组。

语　　法：chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]

补充说明：在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。

参　　数：
　-c或--changes  效果类似"-v"参数，但仅回报更改的部分。
　-f或--quiet或--silent 　不显示错误信息。
　-h或--no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。
　-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
　-v或--verbose 　显示指令执行过程。
　--help 　在线帮助。
　--reference=<参考文件或目录> 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。
　--version 　显示版本信息。

umask

全称:the user file-creation mask

功能说明：指定在建立文件时预设的权限掩码。显示设置文件的缺省权限

语　　法：umask [-S][权限掩码]  以rwx的形式来显示新建文件的缺省权限

补充说明：umask可用来设定[权限掩码]。[权限掩码]是由3个八进制的数字所组成，将现有的存取权限减掉权限掩码后，即可产生建立文件时预设的权限。

参　　数：
  -S 　以文字的方式来表示权限掩码。

直接用umask命令会出现0022值(权限掩码)
0(特殊权限) 0() 2(421中的被减掉的,表示权限r-w) 2(421中的被减掉的,表示权限r-w)
所以修改权限就可以用 umask 023
表示把文件权限改为 754  即 rwxr-xr--

PS: 缺省创建的文件是没有可执行权限的


2016-1-5

    find

    语法 find  [查找范围]   [匹配条件 ]

    示例:$ find /etc -name init

    解释:在目录 /etc 查找名为init 的文件
     [ *init* 表示查找文件名包含init的文件; init* 查找文件名以init开始的文件;
     init??? 查找文件名只有7位且以init开始的文件]
    PS: 此命令为精确查找,文件名区分大小写,如果把 -name 选项换成 -iname 则不区分大小写

    $ find / -size +204800 [数字表数据块, 1数据块=512字节=0.5k ]
    解释: 全盘查找大于100M的文件
    PS: +n 大于  -n小于 n等于

    $ find /home -user shenchao
    解释:在根目录下查找所有者为shenchao的文件
    -group 表示工作组

    $ find /etc -cmin -5
    解释:在/etc下查找5分钟内修改过属性的文件和目录
    -amin [access] 访问时间  -cmin [chgange] 文件属性  -mmin [modify] 文件内容

    $ find /etc -size +163840 -a -size -204800
    解释:在/etc下查找大于80M且小于100M的文件
    -a [and] 两者同时满足   -o [or] 满足任一条件即可

    $ find /etc -name init* -a -type f -exec -ls -l {} \;
    解释:在/etc下查找文件名以init开始的文件并查看文件属性.
    PS: -excu/-ok (-excu执行,不经过询问; -ok 询问,通过后才会执行)

    $ find . -inum 11303 -exec rm {} \;
    解释:在当前目录查找到i节点为11303的文件并删除之.
    引:查看文件的i节点: ls -i


    find

    功能说明：查找文件或目录。

    语　　法：find [目录...][-amin <分钟>][-anewer <参考文件或目录>][-atime <24小时数>][-cmin <分钟>]
    [-cnewer <参考文件或目录>][-ctime <24小时数>][-daystart][-depyh][-empty][-exec <执行指令>]
    [-false][-fls <列表文件>][-follow][-fprint <列表文件>][-fprint0 <列表文件>][-fprintf <列表文件><输出格式>]
    [-fstype <文件系统类型>][-gid <群组识别码>][-group <群组名称>][-help][-ilname <范本样式>][-iname <范本样式>]
    [-inum <inode编号>][-ipath <范本样式>][-iregex <范本样式>][-links <连接数目>][-lname <范本样式>][-ls]
    [-maxdepth <目录层级>][-mindepth <目录层级>][-mmin <分钟>][-mount]
    [-mtime <24小时数>][-name <范本样式>][-newer <参考文件或目录>][-nogroup][noleaf] [-nouser][-ok <执行指令>]
    [-path <范本样式>][-perm <权限数值>][-print][-print0][-printf <输出格式>][-prune][-regex <范本样式>][-size <文件大小>]
    [-true][-type <文件类型>][-uid <用户识别码>][-used <日数>][-user <拥有者名称>][-version][-xdev][-xtype <文件类型>]

    补充说明：find指令用于查找符合条件的文件。任何位于参数之前的字符串都将被视为欲查找的目录。

    参　　数：
    　-amin<分钟> 　查找在指定时间曾被存取过的文件或目录，单位以分钟计算。
    　-anewer<参考文件或目录> 　查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录。
    　-atime<24小时数> 　查找在指定时间曾被存取过的文件或目录，单位以24小时计算。
    　-cmin<分钟> 　查找在指定时间之时被更改的文件或目录。
    　-cnewer<参考文件或目录> 　查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。
    　-ctime<24小时数> 　查找在指定时间之时被更改的文件或目录，单位以24小时计算。
    　-daystart 　从本日开始计算时间。
    　-depth 　从指定目录下最深层的子目录开始查找。
    　-expty 　寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录。
    　-exec<执行指令> 　假设find指令的回传值为True，就执行该指令。
    　-false 　将find指令的回传值皆设为False。
    　-fls<列表文件> 　此参数的效果和指定"-ls"参数类似，但会把结果保存为指定的列表文件。
    　-follow 　排除符号连接。
    　-fprint<列表文件> 　此参数的效果和指定"-print"参数类似，但会把结果保存成指定的列表文件。
    　-fprint0<列表文件> 　此参数的效果和指定"-print0"参数类似，但会把结果保存成指定的列表文件。
    　-fprintf<列表文件><输出格式> 　此参数的效果和指定"-printf"参数类似，但会把结果保存成指定的列表文件。
    　-fstype<文件系统类型> 　只寻找该文件系统类型下的文件或目录。
    　-gid<群组识别码> 　查找符合指定之群组识别码的文件或目录。
    　-group<群组名称> 　查找符合指定之群组名称的文件或目录。
    　-help或--help 　在线帮助。
    　-ilname<范本样式> 　此参数的效果和指定"-lname"参数类似，但忽略字符大小写的差别。
    　-iname<范本样式> 　此参数的效果和指定"-name"参数类似，但忽略字符大小写的差别。
    　-inum<inode编号> 　查找符合指定的inode编号的文件或目录。
    　-ipath<范本样式> 　此参数的效果和指定"-ipath"参数类似，但忽略字符大小写的差别。
    　-iregex<范本样式> 　此参数的效果和指定"-regexe"参数类似，但忽略字符大小写的差别。
    　-links<连接数目> 　查找符合指定的硬连接数目的文件或目录。
    　-iname<范本样式> 　指定字符串作为寻找符号连接的范本样式。
    　-ls 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。
    　-maxdepth<目录层级> 　设置最大目录层级。
    　-mindepth<目录层级> 　设置最小目录层级。
    　-mmin<分钟> 　查找在指定时间曾被更改过的文件或目录，单位以分钟计算。
    　-mount 　此参数的效果和指定"-xdev"相同。
    　-mtime<24小时数> 　查找在指定时间曾被更改过的文件或目录，单位以24小时计算。
    　-name<范本样式> 　指定字符串作为寻找文件或目录的范本样式。
    　-newer<参考文件或目录> 　查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。
    　-nogroup 　找出不属于本地主机群组识别码的文件或目录。
    　-noleaf 　不去考虑目录至少需拥有两个硬连接存在。
    　-nouser 　找出不属于本地主机用户识别码的文件或目录。
    　-ok<执行指令> 　此参数的效果和指定"-exec"参数类似，但在执行指令之前会先询问用户，若回答"y"或"Y"，则放弃执行指令。
    　-path<范本样式> 　指定字符串作为寻找目录的范本样式。
    　-perm<权限数值> 　查找符合指定的权限数值的文件或目录。
    　-print 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称之前皆有"./"字符串。
    　-print0 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行。
    　-printf<输出格式> 　假设find指令的回传值为True，就将文件或目录名称列出到标准输出。格式可以自行指定。
    　-prune 　不寻找字符串作为寻找文件或目录的范本样式。
    　-regex<范本样式> 　指定字符串作为寻找文件或目录的范本样式。
    　-size<文件大小> 　查找符合指定的文件大小的文件。
    　-true 　将find指令的回传值皆设为True。
    　-typ<文件类型> 　只寻找符合指定的文件类型的文件。
    　-uid<用户识别码> 　查找符合指定的用户识别码的文件或目录。
    　-used<日数> 　查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算。
    　-user<拥有者名称> 　查找符合指定的拥有者名称的文件或目录。
    　-version或--version 　显示版本信息。
    　-xdev 　将范围局限在先行的文件系统中。
    　-xtype<文件类型> 　此参数的效果和指定"-type"参数类似，差别在于它针对符号连接检查。

    # 命令:locate   语法:locate [文件名]
    功能描述:在文件资料中查找文件[速度很快]
    手动更新资料库:updatedb [此命令不能更新 /tmp 目录]
    选项: -i [ignore-case]
    PS: 先更新资料库再locate查找文件

    功能说明：查找文件。

    语   法：locate [-d <数据库文件>][--help][--version][范本样式...]

    补充说明：locate指令用于查找符合条件的文件，它会去保存文件与目录名称的数据库内，查找合乎范本样式条件的文件或目录。

    参　　数：
　   -d<数据库文件>或--database=<数据库文件>  设置locate指令使用的数据库。locate指令预设的数据库位于/var/lib/slocate目录里，文件名为slocate.db，您可使用这个参数另行指定。
　   --help 　在线帮助。
　   --version 　显示版本信息。

    # 命令:which    语法: which 命令  如: which ls
    功能:搜索命令所在的目录及别名星系

    # 命令:whereis    语法: whereis 命令 如:whereis ls
    功能:搜索命令所在的目录及帮助文档目录

    # 命令名称:grep    语法: grep -iv [指定字符] [文件名] {功能和windows中的ctrl+f相似}
    选项: -i (ignore-case) 不区分大小写
         -n  显示行号
         -v 排除的字串
    范例: grep mysql /root/install.log
    释义: 在/roo/install.log 文件的内容中查找有mysql字段的句子

    范例: grep -v # /root/install.log
    释义: 在/roo/install.log 文件的内容中查找带#字段的句子

    范例: grep -v ^# /root/install.log
    释义: 在/roo/install.log 文件的内容中查找首#字段的句子

    grep

    功能说明：查找文件里符合条件的字符串。

    语　　法：grep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]

    补充说明：grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为“-”，则grep指令会从标准输入设备读取数据。

    参　　数：
      -a或--text   不要忽略二进制的数据。
      -A<显示列数>或--after-context=<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之后的内容。
      -b或--byte-offset   在显示符合范本样式的那一列之前，标示出该列第一个字符的位编号。
      -B<显示列数>或--before-context=<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之前的内容。
      -c或--count   计算符合范本样式的列数。
      -C<显示列数>或--context=<显示列数>或-<显示列数>   除了显示符合范本样式的那一列之外，并显示该列之前后的内容。
      -d<进行动作>或--directories=<进行动作>   当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
      -e<范本样式>或--regexp=<范本样式>   指定字符串做为查找文件内容的范本样式。
      -E或--extended-regexp   将范本样式为延伸的普通表示法来使用。
      -f<范本文件>或--file=<范本文件>   指定范本文件，其内容含有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每列一个范本样式。
      -F或--fixed-regexp   将范本样式视为固定字符串的列表。
      -G或--basic-regexp   将范本样式视为普通的表示法来使用。
      -h或--no-filename   在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
      -H或--with-filename   在显示符合范本样式的那一列之前，表示该列所属的文件名称。
      -i或--ignore-case   忽略字符大小写的差别。
      -l或--file-with-matches   列出文件内容符合指定的范本样式的文件名称。
      -L或--files-without-match   列出文件内容不符合指定的范本样式的文件名称。
      -n或--line-number   在显示符合范本样式的那一列之前，标示出该列的列数编号。
      -q或--quiet或--silent   不显示任何信息。
      -r或--recursive   此参数的效果和指定“-d recurse”参数相同。
      -s或--no-messages   不显示错误信息。
      -v或--revert-match   反转查找。
      -V或--version   显示版本信息。
      -w或--word-regexp   只显示全字符合的列。
      -x或--line-regexp   只显示全列符合的列。
      -y   此参数的效果和指定“-i”参数相同。
      --help   在线帮助。

    --------------------------------------------------------------------------------

    命令: man     全称:manual       语法: man [命令名称]      示例: man ls
    功能:获得帮助信息
    注意:命令名称不可写成命令的绝对路径

    在Linux里,有两种帮助类型: 1) 1 命令的帮助类型  2) 5 配置文件的帮助类型
    所以可以用# man 5 passwd 来查看passwd的配置文件帮助

    命令:whatis   语法:whatis [命令名称]
    功能描述:只查看命令的用途

    命令:apropos      语法: apropos [命令名称]
    功能描述:查看配置文件的信息

    还有个info 命令的功能和 man相似

    命令:help 查看shell 内置命令的帮助信息

    命令:who      功能:查看登录用户的信息
    tty:本地登录        pts:远程登录

    命令:w        功能:查看登录用户的详细信息
    --------------------------------------------------------------------------------


    gzip(gnu zip)

    功能说明：压缩文件。

    语　　法：gzip [-acdfhlLnNqrtvV][-S <压缩字尾字符串>][-<压缩效率>][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S <压缩字尾字符串>][-<压缩效率>][--best/fast][目录]

    补充说明：gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名。

    参　　数：
    　-a或--ascii 　使用ASCII文字模式。
    　-c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。
    　-d或--decompress或----uncompress 　解开压缩文件。
    　-f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
    　-h或--help 　在线帮助。
    　-l或--list 　列出压缩文件的相关信息。
    　-L或--license 　显示版本与版权信息。
    　-n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。
    　-N或--name 　压缩文件时，保存原来的文件名称及时间戳记。
    　-q或--quiet 　不显示警告信息。
    　-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
    　-S<压缩字尾字符串>或----suffix<压缩字尾字符串> 　更改压缩字尾字符串。
    　-t或--test 　测试压缩文件是否正确无误。
    　-v或--verbose 　显示指令执行过程。
    　-V或--version 　显示版本信息。
    　-<压缩效率> 　压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高。
    　--best 　此参数的效果和指定"-9"参数相同。
    　--fast 　此参数的效果和指定"-1"参数相同。
    --------------------------------------------------------------------------------

    gunzip(gnu unzip)

    功能说明：解压文件。

    语　　法：gunzip [-acfhlLnNqrtvV][-s <压缩字尾字符串>][文件...] 或 gunzip [-acfhlLnNqrtvV][-s <压缩字尾字符串>][目录]

    补充说明：gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为".gz"。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。

    参　　数：
    　-a或--ascii 　使用ASCII文字模式。
    　-c或--stdout或--to-stdout 　把解压后的文件输出到标准输出设备。
    　-f或-force 　强行解开压缩文件，不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
    　-h或--help 　在线帮助。
    　-l或--list 　列出压缩文件的相关信息。
    　-L或--license 　显示版本与版权信息。
    　-n或--no-name 　解压缩时，若压缩文件内含有远来的文件名称及时间戳记，则将其忽略不予处理。
    　-N或--name 　解压缩时，若压缩文件内含有原来的文件名称及时间戳记，则将其回存到解开的文件上。
    　-q或--quiet 　不显示警告信息。
    　-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
    　-S<压缩字尾字符串>或--suffix<压缩字尾字符串> 　更改压缩字尾字符串。
    　-t或--test 　测试压缩文件是否正确无误。
    　-v或--verbose 　显示指令执行过程。
    　-V或--version 显示版本信息。

    --------------------------------------------------------------------------------
    命令: tar         语法: tar [-zcvf] [压缩后的文件名] [原目录]
                          tar [-zxvf] [压缩包.tar.gz]
                      选项:-z 打包的同时压缩/解压缩
                          -c 打包 create
                          -x 解压缩 extract
                          -v 显示详细信息
                          -f 指定文件名


    tar(tape archive)

    功能说明：备份文件。

    语　　法：tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F <Script文件>][-K <文件>]
    [-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>]
    [--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>]
    [--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=<Script文件>][--newer-mtime]
    [--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order]
    [--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>]
    [--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version]
    [--volno-file=<编号文件>][文件或目录...]

    补充说明：tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。

    参　　数：
      -A或--catenate   新增温暖件到已存在的备份文件。
      -b<区块数目>或--blocking-factor=<区块数目>   设置每笔记录的区块数目，每个区块大小为12Bytes。
      -B或--read-full-records   读取数据时重设区块大小。
      -c或--create   建立新的备份文件。
      -C<目的目录>或--directory=<目的目录>   切换到指定的目录。
      -d或--diff或--compare   对比备份文件内和文件系统上的文件的差异。
      -f<备份文件>或--file=<备份文件>   指定备份文件。
      -F<Script文件>或--info-script=<Script文件>   每次更换磁带时，就执行指定的Script文件。
      -g或--listed-incremental   处理GNU格式的大量备份。
      -G或--incremental   处理旧的GNU格式的大量备份。
      -h或--dereference   不建立符号连接，直接复制该连接所指向的原始文件。
      -i或--ignore-zeros   忽略备份文件中的0 Byte区块，也就是EOF。
      -k或--keep-old-files   解开备份文件时，不覆盖已有的文件。
      -K<文件>或--starting-file=<文件>   从指定的文件开始还原。
      -l或--one-file-system   复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。
      -L<媒体容量>或-tape-length=<媒体容量>   设置存放每体的容量，单位以1024 Bytes计算。
      -m或--modification-time   还原文件时，不变更文件的更改时间。
      -M或--multi-volume   在建立，还原备份文件或列出其中的内容时，采用多卷册模式。
      -N<日期格式>或--newer=<日期时间>   只将较指定日期更新的文件保存到备份文件里。
      -o或--old-archive或--portability   将资料写入备份文件时使用V7格式。
      -O或--stdout   把从备份文件里还原的文件输出到标准输出设备。
      -p或--same-permissions   用原来的文件权限还原文件。
      -P或--absolute-names   文件名使用绝对名称，不移除文件名称前的"/"号。
      -r或--append   新增文件到已存在的备份文件的结尾部分。
      -R或--block-number   列出每个信息在备份文件中的区块编号。
      -s或--same-order   还原文件的顺序和备份文件内的存放顺序相同。
      -S或--sparse   倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。
      -t或--list   列出备份文件的内容。
      -T<范本文件>或--files-from=<范本文件>   指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。
      -u或--update   仅置换较备份文件内的文件更新的文件。
      -U或--unlink-first   解开压缩文件还原文件之前，先解除文件的连接。
      -v或--verbose   显示指令执行过程。
      -V<卷册名称>或--label=<卷册名称>   建立使用指定的卷册名称的备份文件。
      -w或--interactive   遭遇问题时先询问用户。
      -W或--verify   写入备份文件后，确认文件正确无误。
      -x或--extract或--get  从备份文件中还原文件。
      -X<范本文件>或--exclude-from=<范本文件>  指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。
      -z或--gzip或--ungzip   通过gzip指令处理备份文件。
      -Z或--compress或--uncompress   通过compress指令处理备份文件。
      -<设备编号><存储密度>   设置备份用的外围设备编号及存放数据的密度。
      --after-date=<日期时间>   此参数的效果和指定"-N"参数相同。
      --atime-preserve   不变更文件的存取时间。
      --backup=<备份方式>或--backup   移除文件前先进行备份。
      --checkpoint   读取备份文件时列出目录名称。
      --concatenate   此参数的效果和指定"-A"参数相同。
      --confirmation   此参数的效果和指定"-w"参数相同。
      --delete   从备份文件中删除指定的文件。
      --exclude=<范本样式>   排除符合范本样式的问家。
      --group=<群组名称>   把加入设备文件中的文件的所属群组设成指定的群组。
      --help   在线帮助。
      --ignore-failed-read   忽略数据读取错误，不中断程序的执行。
      --new-volume-script=<Script文件>   此参数的效果和指定"-F"参数相同。
      --newer-mtime   只保存更改过的文件。
      --no-recursion   不做递归处理，也就是指定目录下的所有文件及子目录不予处理。
      --null   从null设备读取文件名称。
      --numeric-owner   以用户识别码及群组识别码取代用户名称和群组名称。
      --owner=<用户名称>   把加入备份文件中的文件的拥有者设成指定的用户。
      --posix   将数据写入备份文件时使用POSIX格式。
      --preserve      此参数的效果和指定"-ps"参数相同。
      --preserve-order      此参数的效果和指定"-A"参数相同。
      --preserve-permissions      此参数的效果和指定"-p"参数相同。
      --record-size=<区块数目>      此参数的效果和指定"-b"参数相同。
      --recursive-unlink   解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。
      --remove-files   文件加入备份文件后，就将其删除。
      --rsh-command=<执行指令>   设置要在远端主机上执行的指令，以取代rsh指令。
      --same-owner   尝试以相同的文件拥有者还原问家你。
      --suffix=<备份字尾字符串>   移除文件前先行备份。
      --totals   备份文件建立后，列出文件大小。
      --use-compress-program=<执行指令>   通过指定的指令处理备份文件。
      --version   显示版本信息。
      --volno-file=<编号文件>   使用指定文件内的编号取代预设的卷册编号。

    --------------------------------------------------------------------------------

    命令名称:zip        语法:zip 选项[-r] [压缩后文件名.zip] [欲打包的文件或目录]
            -r recursive  目录
    功能描述:压缩文件或者目录
        zip优点: 1.zip压缩包 windows和 linux系统通用
                2.zip压缩的同事会保留原文件或目录
                3.zip既可以打包文件,也可以打包目录

    命令名称:unzip      语法:unzip test.zip
    功能描述:解压缩

    --------------------------------------------------------------------------------
    命令:bzip2        语法:bzip2 [-k] [文件]
                 选项:-k    keep 产生压缩文件后保留原文件
                 压缩后文件格式: bz.2
    PS:还可以和tar结合使用:$ tar -jcvf (把z替换成j) Japan.tar.bz2 Japan

    命令:bunzip2      语法:bunzip2 [-k] [压缩文件.bz2]
                  选项:-k    解压后保留原文件
                  $ bunzip2 -k boduo.bz2
    PS:也可以和tar结合使用:$ tar -jxvf (把z替换成j) Japan.tar.bz2
    --------------------------------------------------------------------------------
    命令:write        语法:write <用户名>
    功能描述:按回车写入信息内容,以Ctrl+D(或者键入EOF)保存结束并给用户发信息;Ctrl+退格键删除信息内容

    write

    功能说明：传送信息。

    语　　法：write [用户名称][终端机编号]

    补充说明：通过write指令可传递信息给另一位登入系统的用户，当输入完毕后，键入EOF表示信息结束，write指令就会将信息传给对方。
    如果接收信息的用户不只登入本地主机一次，你可以指定接收信息的终端机编号。
    --------------------------------------------------------------------------------
    wall(write all)

    功能说明：传送信息。

    语　　法：wall [公告信息]

    补充说明：通过wall指令可将信息发送给每位同意接收公众信息的终端机用户，若不给予其信息内容，
    则wall指令会从标准输入设备读取数据，然后再把所得到的数据传送给所有终端机用户。
    --------------------------------------------------------------------------------
    ping

    功能说明：检测主机。

    语　　法：ping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]

    补充说明：执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。

    参　　数：
      -d   使用Socket的SO_DEBUG功能。
      -c<完成次数>   设置完成要求回应的次数。
      -f   极限检测。
      -i<间隔秒数>   指定收发信息的间隔时间。
      -I<网络界面>   使用指定的网络界面送出数据包。
      -l<前置载入>   设置在送出要求信息之前，先行发出的数据包。
      -n   只输出数值。
      -p<范本样式>   设置填满数据包的范本样式。
      -q   不显示指令执行过程，开头和结尾的相关信息除外。
      -r   忽略普通的Routing Table，直接将数据包送到远端主机上。
      -R   记录路由过程。
      -s<数据包大小>   设置数据包的大小。
      -t<存活数值>   设置存活数值TTL的大小。
      -v   详细显示指令的执行过程。

    --------------------------------------------------------------------------------

    ifconfig

    功能说明：显示或设置网络设备。

    语　　法：ifconfig [网络设备][down up -allmulti -arp -promisc][add<地址>][del<地址>][<hw<网络设备类型><硬件地址>][io_addr<I/O地址>][irq<IRQ地址>][media<网络媒介类型>][mem_start<内存地址>][metric<数目>][mtu<字节>][netmask<子网掩码>][tunnel<地址>][-broadcast<地址>][-pointopoint<地址>][IP地址]

    补充说明：ifconfig可设置网络设备的状态，或是显示目前的设置。

    参　　数：
      add<地址>   设置网络设备IPv6的IP地址。
      del<地址>   删除网络设备IPv6的IP地址。
      down   关闭指定的网络设备。
      <hw<网络设备类型><硬件地址>   设置网络设备的类型与硬件地址。
      io_addr<I/O地址>   设置网络设备的I/O地址。
      irq<IRQ地址>   设置网络设备的IRQ。
      media<网络媒介类型>   设置网络设备的媒介类型。
      mem_start<内存地址>   设置网络设备在主内存所占用的起始地址。
      metric<数目>   指定在计算数据包的转送次数时，所要加上的数目。
      mtu<字节>   设置网络设备的MTU。
      netmask<子网掩码>   设置网络设备的子网掩码。
      tunnel<地址>   建立IPv4与IPv6之间的隧道通信地址。
      up   启动指定的网络设备。
      -broadcast<地址>   将要送往指定地址的数据包当成广播数据包来处理。
      -pointopoint<地址>   与指定地址的网络设备建立直接连线，此模式具有保密功能。
      -promisc   关闭或启动指定网络设备的promiscuous模式。
      [IP地址]   指定网络设备的IP地址。
      [网络设备]   指定网络设备的名称。
    --------------------------------------------------------------------------------

    命令:mail     语法:mail [用户名]
    功能:1.向指定用户发送邮件
        2.查看邮件   输入邮件前的序号(如1)即可查看对应的邮件
         输入h可以返回邮件列表
         输入 d 1可以删除序号为1的邮件
         输入q可以退出邮件界面
    --------------------------------------------------------------------------------
    命令:last     功能:列出目前与过去登入系统的用户信息
    命令:lastlog  功能:查看用户最后一次登入信息
        #lastlog -u 502(用户uid) 可以查看特定用户的最后一次登入信息
    --------------------------------------------------------------------------------

    命令:traceroute   功能:显示数据包到主机间的路径
        #traceroute www.baidu.com

    traceroute

    功能说明：显示数据包到主机间的路径。

    语　　法：traceroute [-dFlnrvx][-f<存活数值>][-g<网关>...][-i<网络界面>][-m<存活数值>][-p<通信端口>][-s<来源地址>][-t<服务类型>][-w<超时秒数>][主机名称或IP地址][数据包大小]

    补充说明：traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。

    参　　数：
      -d   使用Socket层级的排错功能。
      -f<存活数值>   设置第一个检测数据包的存活数值TTL的大小。
      -F   设置勿离断位。
      -g<网关>   设置来源路由网关，最多可设置8个。
      -i<网络界面>   使用指定的网络界面送出数据包。
      -I   使用ICMP回应取代UDP资料信息。
      -m<存活数值>   设置检测数据包的最大存活数值TTL的大小。
      -n   直接使用IP地址而非主机名称。
      -p<通信端口>   设置UDP传输协议的通信端口。
      -r   忽略普通的Routing Table，直接将数据包送到远端主机上。
      -s<来源地址>   设置本地主机送出数据包的IP地址。
      -t<服务类型>   设置检测数据包的TOS数值。
      -v   详细显示指令的执行过程。
      -w<超时秒数>   设置等待远端主机回报的时间。
      -x   开启或关闭数据包的正确性检验。

    --------------------------------------------------------------------------------

    命令:netstat      语法:netstat  [选项]
                选项: -t      tcp协议            安全可靠,相当于打电话
                     -u       udp协议            速度快,相当于收短信,可能收到也可能收不到
                     -l(listen)   监听
                     -r(route)      路由
                     -n          显示IP和端口号
                PS:IP地址相当于门牌号,而端口相当于收件人.

    范例: #netstat -tlun          查看本机监听的端口/查看开了的端口
          netstat -an             查看本机的网络连接,查看所有监听信息,可查看到正在连接的程序
          netstat -rn             查看本机路由表

    netstat

    功能说明：显示网络状态。

    语　　法：netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]

    补充说明：利用netstat指令可让你得知整个Linux系统的网络情况。

    参　　数：
      -a或--all   显示所有连线中的Socket。
      -A<网络类型>或--<网络类型>   列出该网络类型连线中的相关地址。
      -c或--continuous   持续列出网络状态。
      -C或--cache   显示路由器配置的快取信息。
      -e或--extend   显示网络其他相关信息。
      -F或--fib   显示FIB。
      -g或--groups   显示多重广播功能群组组员名单。
      -h或--help   在线帮助。
      -i或--interfaces   显示网络界面信息表单。
      -l或--listening   显示监控中的服务器的Socket。
      -M或--masquerade   显示伪装的网络连线。
      -n或--numeric   直接使用IP地址，而不通过域名服务器。
      -N或--netlink或--symbolic   显示网络硬件外围设备的符号连接名称。
      -o或--timers   显示计时器。
      -p或--programs   显示正在使用Socket的程序识别码和程序名称。
      -r或--route   显示Routing Table。
      -s或--statistice   显示网络工作信息统计表。
      -t或--tcp   显示TCP传输协议的连线状况。
      -u或--udp   显示UDP传输协议的连线状况。
      -v或--verbose   显示指令执行过程。
      -V或--version   显示版本信息。
      -w或--raw   显示RAW传输协议的连线状况。
      -x或--unix   此参数的效果和指定"-A unix"参数相同。
      --ip或--inet   此参数的效果和指定"-A inet"参数相同。
    --------------------------------------------------------------------------------
    命令:setup                功能说明：设置公用程序。

    语　　法：setup
    补充说明：setup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：
    　１.登陆认证方式
    　２.键盘组态设置
    　３.鼠标组态设置
    　４.开机时所要启动的系统服务
    　５.声卡组态设置
    　６.时区设置
    　７.X Windows组态设置
    PS:在CentOS 7.0 以后的版本里,setup里不再有网络配置选项.
    但是可以进行以下操作:
    # yum install NetworkManager-tui
    然后输入 #nmtui
    如果提示 NetworkManager is not running 则通过下面命令进行手动开启:
    #systemctl start NetworkManager
    然后再运行 #nmtui
    --------------------------------------------------------------------------------
    命令:mount        语法: mount -t [文件系统]   设备文件名   挂载点
    示例: #mount -t iso9660 /dev/sr0 /mnt/cdrom
    --------------------------------------------------------------------------------
    shutdown

    功能说明：系统关机指令。

    语　　法：shutdown [-efFhknr][-t 秒数][时间][警告信息]

    补充说明：shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。

    参　　数：
    　-c 　当执行"shutdown -h 11:50"指令时，只要按+键就可以中断关机的指令。
    　-f 　重新启动时不执行fsck。
    　-F 　重新启动时执行fsck。
    　-h 　将系统关机。
    　-k 　只是送出信息给所有用户，但不会实际关机。
    　-n 　不调用init程序进行关机，而由shutdown自己进行。
    　-r 　shutdown之后重新启动。
    　-t<秒数> 　送出警告信息和删除信息之间要延迟多少秒。
    　[时间] 　设置多久时间后执行shutdown指令。
    　[警告信息] 　要传送给所有登入用户的信息。
    --------------------------------------------------------------------------------
    init 系统运行级别:
    0 关机        1 单用户       2 不完全多用户,不含NFS服务        3 完全多用户     4 未分配       5 图形界面
    6 重启

    #runlevel 可以查询系统运行级别   显示 5(前一个运行级别) 3(当前运行级别)
    #logout     退出当前登录的用户,退出到登录界面
    --------------------------------------------------------------------------------
    命令:vi/vim       新建或编辑文本文件

    插入命令                  命令释义
       a                在光标所在字符后插入
       A                在光标所在行行尾后插入
       i                在光标所在字符前插入
       I                在光标所在行行首插入
       o                在光标下行插入新行
       O                在光标上行插入新行

    定位命令                   命令释义
    :set nu             设置行号
    :set nonu           取消行号
    gg                  到第一行
    G                   到最后一行
    nG                  删除到第n行
    :n                  直接跳转到第n行
    $                   移至行尾
    0                   移至行首

    复制,剪切和粘贴
    命令                   命令释义
    yy                  复制当前行
    nyy                 复制当前行下n行
    dd                  剪切当前行
    ndd                 剪切当前行下n行
    p,P                 粘贴在当前光标所在行的下面或者上面

    命令                  命令释义
    r                   替换光标所在处字符
    R                   从光标所在处开始替换按ESC结束
    u                   取消上一步操作
    x                   向后删除一个字符
    nx                  向后删除n个字符,n表示数字
    X                   向前删除一个字符

    搜索和搜索替换
    命令                    命令释义
    /查找内容              搜索指定内容,搜索是忽略大小写:set ic(ignore case)
    n                     搜索指定字符串的下一个出现位置
    :%s/old/new/g         全文替换内容(g 表示不询问,c 表示询问)
    :n1,n2s/old/new/g     范围内替换内容(g 表示不询问,c 表示询问)

    保存和退出

    命令                      命令释义
    :w                      保存修改
    :w 新文件名              另存为新文件名
    :wq                     保存并退出
    ZZ                      快捷键,保存并退出
    :q!                     不保存修改并退出
    :wq!                    保存修改并退出(文件所有者及root可用)
    --------------------------------------------------------------------------------
    vim 使用技巧
    1. 导入命令执行结果:
        :r !命令
        ① :r filename    将文件导入到光标当前的位置
        ② :! command     可以在不退出vim的情况下执行相对应command的操作
        结合示例: :r !date  释义:在当前光标位置插入当前的时间

    2. 定义快捷键:
       语法       :map 快捷键  出发命令
       示例       :map ^P I#<ESC>
       释义       Ctrl+P(^表示 Ctrl+V,^P表示Ctrl+V+P)  在光标当前行行首插入(I)#并退出命令界面(ESC)
       示例       :map ^B 0x
       释义       Ctrl+B(^表示 Ctrl+V,^P表示Ctrl+V+B)  在光标当前行行首(0)删除#

    3.连续注释:
        ①命令:       :n1,n2s/^/#/g
         释义:    在n1到n2这一范围内的所有行首加个#
         PS:  这里的^表示行首(shift+6)
        ②命令:        :n1,n2s/^#//g
        释义:     把n1行到n2行这一范围内的所有首字符为#的行的首字付替换为空,即取消注释
        ③命令:        :n1,n2s/^/\/\//g
        释义:    在n1到n2这一范围内的所有行首加个//
        PS: 这里的\是转义符,表示后面的"/"是单纯的/

    4. 输入a回车后显示成b:
        ①命令:        :ab mymail aphey@yeah.net
        释义:     只要在vim里输入mymail,按回车后都自动显示为 aphey@yeah.net

    注意点: 可以把上面这些设置保存起来,这样电脑重启,或者关机,这些配置依然永久有效.
    配置文件为用户的宿主目录下的.vimrc(root 用户的绝对路径为/root/.vimrc; aphey用户为/home/aphey/.vimrc)
    如我要设置一个快捷键 Ctrl+P 来对某一行进行注释,我只要在/root/.vimrc里添加下面这句
    map ^P I#<ESC>(前面千万不要加:)
    --------------------------------------------------------------------------------
    CentOs 软件包分类
    1> 源码包
        ●脚本安装包(类似于windows里的安装文件)
       优点:
           ◇ 开源,如果有足够的能力,可以修改源代码
           ◇ 可以自由选择所需的功能
           ◇ 软件是系统编译安装,所以更加适合自己的系统,更加稳定和高效
           ◇ 卸载方便,直接删除安装位置
       缺点:
           ◇ 安装步骤较多,尤其安装较大的软件集合时(如Lamp环境搭建),容易出现拼写错误
           ◇ 编译过程时间较长,安装比二进制安装时间长
           ◇ 因为是编译安装,安装过程中一旦报错新手很难解决

    2> 二进制包(rpm包,系统默认包[光盘镜像的package里都是rpm包])
       优点
          ◇ 包管理系统简单,只通过几个命令就可以实现包的安装、升级、查询和卸载
          ◇ 安装速度比源码包安装快的多
       缺点
          ◇ 经过编译,不再可以看到源代码
          ◇ 功能选择不如源码包灵活
          ◇ 依赖性
    源码包和RPM包的安装位置区别
        源码包的安装位置:
        安装在指定位置当中,一般是 /usr/local/软件名/

        RPM包的安装位置:
        /etc/                配置文件,安装目录
        /usr/bin/            可执行的命令安装目录
        /usr/lib/            程序所使用的函数库保存位置
        /usr/share/doc/      基本的软件使用手册保存位置
        /usr/share/man/      帮助文件保存位置
    安装位置不同带来的影响
    (1)RPM包安装的服务可以使用系统服务管理命令(service)来管理,例如RPM包安装的apache启动方法是:
        方法1. /etc/rc.d/init.d/httpd start   //绝对路径启动方法,进入路径然后启动
        方法2. # service httpd start          //系统简化命令
    (2)源码包的服务启动方法:
        方法:/usr/local/apache2/bin/apachectl start   //绝对路径启动方法,适用于所有软件包,先进入路径再执行
    (3)源码包安装的注意事项
        1.源码包的保存位置: /usr/local/src
        2.软件安装位置: /usr/local/
    (4)源码包安装步骤:
        1.下载源码包
        2.解压缩下载的源码包
        3.进入解压缩目录     // #cd /http-2.2.29/(目录下的INSTALL 是安装说明;README是使用说明)
    (5)软件配置和检查
        1.定义需要的功能选项;
        2.检测系统环境是否符合安装要求;
        3.把定义好的功能与选项和检测系统环境的信息都写入Makefile文件,用于后续的编辑.
        4. 用./configure --prefix=/usr/local/apache  来定义软件安装路径
        5.执行编译
        #make  //执行即可
        ***如果步骤4或者5报错,输入 #make clean  //清空编译产生的临时文件
        6.执行安装
        #make install
        7.运行软件(例如apache,运行方法在INSTALL里有)
        #/usr/local/apache/bin/apachectl start
    (6)源码包的卸载
        源码包的卸载不需要任何命令,直接删除安装目录即可,不会遗留任何系统垃圾
****一般对外访问,访问人数很大,如apache,用源码包安装比较好;
    如果不对外访问,如本机访问,则用rpm包比较方便
    --------------------------------------------------------------------------------
    RPM软件管理
    1> -rpm手动命令管理
        a)rpm包命名规则:
            httpd-2.2.15-15.el6.centos.1.i686.rpm
            ◇ httpd         软件包名
            ◇ 2.2.15        软件版本
            ◇ 15            发布次数
            ◇ el6.centos    适合的linux平台
            ◇ i686          适合的硬件平台(注意有32位64位区别,noarch 表示任何硬件平台都能安装)
            ◇ rpm           软件包扩展名
        b)rpm依赖性:
            ◇ 树形依赖: a→b→c
            ◇ 环形依赖: a→b→c→a
            ◇ 模块依赖: 模块依赖查询:www.rpmfind.net
        c)rpm命令管理:安装、升级和卸载
            ◇ 安装
              ( 包全名: 操作包是没有安装的软件包时,必须使用包全名,并且要注意路径.
              ( 包名:操作已经安装的软件包时,使用包名,是搜索/var/lib/rpm/中的搜索
              命令: rpm -ivh 包全名
                  选项: -i (install) 安装
                       -v(verbose)  显示详细信息
                       -h(hash)     显示进度
                       --nodeps       不检测依赖性
            ◇ 升级
              命令: rpm -Uvh 包全名
                  选项: -U (Upgrade) 升级
            ◇ 卸载
              命令: rpm -e 包名
                  选项: -e (erase)  卸载
                       --nodeps    不检测依赖性
            ◇ 查询
              命令: rpm -q 包名     功能:查询包是否已经安装
                  选项: -q (query) 查询
              命令: rpm -qa        功能:查询所有已安装的rpm包
                  选项: -a (all)
              命令: rpm -qi 包名       功能:查询已安装软件的详细信息
                  选项: -i (information)  信息
              命令: rpm -qip 包全名    功能:查询未安装包的详细信息
                  选项: -p (package)
              命令: rpm -ql 包名       功能:查询已安装包中文件的安装位置
                  选项: -l (list)    列表
                       -p (package)  查询未安装包中文件的安装位置
              命令: rpm -qf 系统文件名  功能:查询系统文件属于哪个rpm包
                  选项: -f (file) 文件
            ◇ 命令: rpm -qR 包名      功能:查询包的依赖性
                  选项 -R (Requires) 查询包的依赖性
                       -p       查询未安装包的依赖性
            ◇ 命令: rpm -V 包名       功能:校验指定rpm包中的文件
                  选项: -V (Verify)  校验指定rpm包中的文件
                  验证内容中8个信息的具体内容
                  S： 文件大小是否改变
                  M： 文件的类型或权限（rwx）是否被改变
                  5： MD5校验是否发生改变（可以理解为文件是否发生改变）
                  D： 设备的中，从代码中是否发生改变
                  L： 文件的路径是否发生改变
                  U： 文件的属主（所有者）是否发生变化
                  G： 文件的属组是否发生变化
                  T： 文件的修改时间是否发生变化
                  文件类型:
                  c：配置文件(config)
                  d：普通文档(documentation)
                  g："鬼"文件(ghost file),很少见,就是该文件不应该被这个RPM包包含
                  l：授权文件(license file)
                  r：描述文件(readme)

            ◇ 命令: rpm2cpio 包全名 | \ (| 管道命令,即把命令1的结果作为命令2的输入传输给命令2; \ 表示一行命令没有输完,换行 )
            cpio -idv .绝对路径(. 表示当前目录)
                  选项 -idv .文件绝对路径
                  rpm2cpio
                  # 将rpm包转换成cpio格式的命令
                  cpio
                  # 是一个标准工具,它用于创建软件档案文件和从档案文件中提取文件
            ◇ 命令: cpio 选项 < [文件/设备]
                  cpio 选项:
                  -i: copy-in模式,还原
                  -d: 还原时自动新建目录
                  -v: 显示还原过程


    2> -yum在线命令管理
        ◇ -yum命令的产生就是为了解决-rpm依赖性问题, yum既可以使用网络yum源,也可以拿本地光盘做yum源.
        问题:yum源如果是redhat系列的,需要收费;
            yum管理的也是RPM包
        ◇ IP地址配置和网络yum源
            a. CentOS 6.5以前:
               # setup //运行网络配置服务
               # vi /etc/sysconfig/network-scrips/ifcfg-eth0
               把ONBOOT="no" 改为  ONBOOT="yes"  // 启动网卡
               # service network restar  //重启网络服务
            b. CentOS 7:
               # yum install NetworkManager-tui  //安装网络配置管理工具
               # nmtui   //运行网络配置管理工具
               # service network restar  //重启网络服务
        yum 源 软件池解释;
            [base]                              //容器名称,一定要放在[]中;
            name=CentOS-$releasever - Base      //容器说明,可以随便写;
            mirrorlist=http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=os&infra=$infra
            // 镜像站点,这个可以注释掉;
            #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
            // yum源地址服务器地址,默认是官方的yum服务器,如果觉得慢,可以换成自己喜欢的yum源地址;
            gpgcheck=1 // 如果是1,说明rpm的数字认证是生效的,0则为不生效;
            gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7  //数字证书的公钥文件保存位置,不用修改;
            enabled=1  //此容器是否生效,如果本行不写,或者enabled=1,表示本容器是生效的,enabled=0则表示不生效;
    3> 常用yum命令
        命令: #yum list       功能:查询所有可用软件包列表
        命令: #yum serch 关键字(包名)       功能:搜索服务器上和关键字相关的包
        命令: #yum -y install 包名       功能:安装软件包       选项: -y 自动回答yes
        命令: #yum -y update 包名       功能:升级软件包       选项: -y 自动回答yes
        命令: #yum -y update 包名       功能:升级软件包       选项: -y 自动回答yes
        * 注意:#yum -y update 表示升级所有软件包,包括Centos的内核,升级后的内核需要在本机进行一定的配置才能生效,否则
        电脑无法开机连接,务必注意
        命令: #yum -y remove 包名       功能:卸载软件包       选项: -y 自动回答yes
        * 注意:yum卸载软件时,会卸载软件相关的依赖包,而这些依赖包可能被系统所依赖,一旦卸载,系统可能会崩溃,所以,CentOS最好是最小化安装
        然后用什么,就安装什么,安装了尽量不要卸载
        命令: #yum grouplist      功能:查询软件组(功能组,如最小安装,基础设施服务器)
        命令: #yum -y groupinstall 软件组名      功能:安装指定软件组(由grouplist查询而来)
        命令: #yum -y groupremove 软件组名      功能:卸载指定软件组
    4> 光盘yum源搭建
        ⒈ 挂载光盘
           # mount /dev/cdrom /mnt/cdrom
        ⒉ 让网络yum源失效
           方法:把/etc/yum.repo.d 目录下除了CentOS-Media.repo 之外的全部改名即可
           # cd /etc/yum.repo.d  //进入/etc/yum.repo.d目录
           # mv CentOS-Base.repo CentOS-Base.repo.bak //把CentOS-Base.repo重命名为CentOS-Base.repo.bak,这样就不能被系统识别
           其他依次更改
        ⒊ 修改光盘yum源
           # cd /etc/yum.repo.d  //进入/etc/yum.repo.d目录
           # vim CentOS-Media.repo  //修改光盘yum源配置文件
           [c7-media]
           name=CentOS-$releasever - Media
           baseurl=file:///media/cdrom/         //地址为光盘的挂载地址
           #        file:///media/cdrom/         //注释掉这个不存在的地址;不影响,但是会报错,看着烦(Linux 注释的# 需在行首)
           #        file:///media/cdrecorder/    //注释掉这个不存在的地址;不影响,但是会报错,看着烦(Linux 注释的# 需在行首)
           gpgcheck=1
           enabled=1    //把enabled=0 改为enabled=1 使配置生效
           gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
    --------------------------------------------------------------------------------
    Linux软件包管理
        脚本安装包
            ◇ 脚本安装包并不是独立的软件包类型,常见安装的是源码包
            ◇ 是人为的把安装过程写成了自动安装的脚本,只要执行脚本,定义简单的参数,就可以完成安装
            ◇ 非常类似于windows下的软件安装方式
        Linux中主要的脚本安装包是硬件的驱动,厂商为了推销自己的硬件会推行脚本安装
            示例:安装webmin, 通过网页管理Linux
                ( 下载tar.gz, 解压缩
                ( 解压缩,进入目录
                ( # ./setup.sh    //运行安装脚本
                ( 一路回车和y

    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
第七章 用户和用户组管理

    7.1.1 用户信息文件 /etc/passwd
       # vim /etc/passwd    //查看/etc/passwd 配置文件
       ****复习: 当配置文件很复杂的时候可以用# man 5 passwd 来寻求帮助

        /etc/passwd 配置文件
       ◇ 第1字段:用户名称
       ◇ 第2字段:密码标注
       ◇ 第3字段:UID(用户ID)
         · 0:        超级用户
         · 1-499:    系统用户
         · 500-65535:   普通用户
       ****可以把普通用户的UID改成0,系统会把他和超级用户一起默认地当做一个人,都具有超级用户的权限
       ◇ 第4字段: GID (用户初始组ID)
         用户组类型:初始组和附加组
         ● 初始组:就是用户一登录就立刻拥有这个用户组的相关权限,每个用户的初始组只能有一个,
         一般就是和这个用户名相同的组名作为这个用户的初始组
         ● 附加组:指用户可以加入多个其他的用户组,并拥有这些组的权限,附加组可以有多个
       ◇ 第5字段: 用户说明

       ◇ 第6字段: 家目录(宿主目录)
         · 普通用户: /home/用户名/
         · 超级用户: /root/
       ◇ 第7字段: 登录之后的Shell
         · shell就是Linux的命令解释器
         · 在/etc/passwd当中, 除了标准Shell是 /bin/bash之外, 还可以写如/sbin/nologin
    --------------------------------------------------------------------------------
    7.1.2 影子文件 /etc/shadow
       /etc/shadow 其实是 /etc/passwd的影子文件
       # vim /etc/shadow    //查看/etc/shadow 配置文件
       有9个字段
       ◇ 第1字段:用户名称
       ◇ 第2字段:加密密码
           ● 加密算法升级为SHA512散列加密算法
           ● 如果密码是"!!" 或"*"代表没有密码,不能登录
           ● 在普通用户加密密码前加"!" 使该用户密码失效 禁用此用户
       ◇ 第3字段:密码最后一次修改日期
           ● 使用1970年1月1日作为标准时间,每过一天时间戳加1
       ◇ 第4字段: 两次密码修改的时间间隔(和第三字段相比较)
           ● 假如数字为10,就是指在第一次密码设定好10天之后才可以改密码
       ◇ 第5字段: 密码有效期(和第三字段相比较)
           ● 可以设定密码的时效性
       ◇ 第6字段: 密码到期前的警告天数(和第五字段相比较)
           ● 假如数字为7,就是密码有效期的最后7天每当用户登录时会给用户发送警告信息
       ◇ 第7字段: 密码过期后的宽限天数(和第五字段相比)
           ● -1 表示密码永远不会失效
           ● 0 or 留空 表示到有效期结束的时候用户没改密码, 该用户会被禁止登录
       ◇ 第8字段: 账号失效时间
           ● 要用时间戳表示
           ● 时间戳换算公式
               把时间戳换算成日期:
                   # date -d "1970-01-01 16066 days"
               把日期换算成时间戳:
                   # echo $(($(date --date="2014/01/06" +%s)/86400+1))
       ◇ 第9字段:保留
    --------------------------------------------------------------------------------
    7.1.3 组信息文件/etc/group 和 组密码文件 /etc/gshadow
       #vim /etc/group
       ◇ 第1字段:组名
       ◇ 第2字段:组密码标志
       ◇ 第3字段:GID(group ID)
              · 0:        超级用户
              · 1-499:    系统用户
              · 500-65535:   普通用户
       ◇ 第4字段: 组中附加用户

       #vim /etc/gshadow
        ◇ 第1字段:组名
        ◇ 第2字段:组密码标志
        ◇ 第3字段:GID(group ID)
         · 0:        超级用户
         · 1-499:    系统用户
         · 500-65535:   普通用户
        ◇ 第4字段: 组中附加用户
    --------------------------------------------------------------------------------
    7.2 用户管理相关文件:
        1.用户的家目录
            ( 普通用户:/home/用户名/,所有者和所属组都是此用户,权限是700)
            ( 超级用户:/root/,所有者和所属组都是root用户,权限是550)
        2.用户的邮箱
             ( /var/spool/mail/用户名/)
        3.用户模板目录   //创建新用户的时候,该新用户的家目录会复制此目录中的文件
             ( /etc/skel/
    --------------------------------------------------------------------------------
    7.3.1 用户管理命令 useradd
        1. useradd命令格式: #useradd [选项] 用户名
        // 如果不给新添加的用户设置密码,那么此用户是不完整的,是没法登陆的
        选项:
            -u UID: 手工指定用户的UID号
            -d 家目录: 手工指定用户的家目录
            -c 用户说明: 手工指定用户的说明
            -g 组名: 手工指定用户的初始组 // 不建议修改,一般指定附加组
            -G 组名: 指定用户的附加组,多个附加组之间用","分隔;而且这些组是系统里必须已经存在.
            -s shell:手工指定用户的登录shell. 默认是/bin/bash
        Example:#useradd -u 666 -G root,bin -c "test user" -d /subeiafei -s /bin/bash subeiafei
        解释:添加subeiafei 用户,他的UID为 666, 附加组为root和bin, 解释说明 此用户为测试用户,家目录为根目录下的subeiafei文件夹,
            shell为 /bin/bash
        2.用户默认值文件:
            /etc/default/useradd
                  GROUP=100    //用户默认组
                  HOME=/home   //用户家目录
                  INACTIVE=-1  //密码过期宽限天数(shadow文件第七字段)
                  EXPIRE=      //密码失效时间(shadow文件第八字段)
                  SHELL=/bin/bash  //默认shell
                  SKEL=/etc/skel  //模板目录
                  CREATE_MAIL_SPOOL=yess   //是否建立邮箱
            另外一个定义用户的文件
             /etc/login.defs
                PASS_MAX_DAYS 99999  //密码有效期(shadow文件第5字段)
                PASS_MIN_DAYS 0     //密码修改间隔(shadow文件第4字段)
                PASS_MIN_LEN  5     //密码最小5位(PAM)
                PASS_WARN_AGE 7     //密码到期警告(shadow文件第6字段)
                UID_MIN        500    //最小和最大UID范围
                GID_MAX        60000
                ENCRYPT_METHOD    SHA512    //加密模式
    --------------------------------------------------------------------------------
    7.3.2 用户管理命令 passwd
        命令:#passwd [选项] 用户名  // 常用的格式是 passwd 用户名
        选项: -S 查询用户密码的密码状态.仅root用户可用.
              -l 暂时锁定用户.仅root用户可用
              -u 解锁用户. 仅root用户可用
              --stdin  可以通过管道符输出的数据作为用户密码
        *** 可以直接输入passwd命令,意思为直接为当前用户设置密码
            只有超级用户可以在passwd 后面接用户名;普通用户不能在后面接用户名
            超级用户可以改自己密码,也可以为其他用户改密码; 普通用户只能用$ passwd 来更改自己的密码
    --------------------------------------------------------------------------------
    7.3.3 用户管理命令 usermod
       1)# usermod [选项] 用户名
         -u UID: 修改用户的UID号
         -c 用户说明: 修改用户的说明信息(如果说明中间有括号,说明部分要用引号包含,如果没有空格 可以不用引号)
         -G 组名: 修改用户的附加组
         -L Lock:临时解锁用户
         -U Unlock; 解锁用户锁定
       2) 修改用户密码状态chage
         #chage [选项] 用户名
         -l:  列出用户的详细密码状态
         -d 日期:修改密码最后一次的更改日期(shadow 3 字段)
         -m 天数:两次密码修改间隔(shadow 4 字段)
         -M 天数:密码有效期(shadow 5 字段)
         -W 天数:密码过期钱警告天数(shadow 6 字段)
         -I 天数:密码过期后宽限天数(shadow 7 字段)
         -E 日期:账号失效时间(shadow 8 字段)
        #chage -d 0 用户名  //此命令用的最多, 是把密码修改日期归零了,意思是要求用户初次登陆就要改密码
    --------------------------------------------------------------------------------
    7.3.4 用户命令管理userdel 和su
        1) 删除用户userdel
            #userdel -r 用户名    //删除用户的同时删除用户家目录,如果不用-r那么原用户的家目录就会变成没有所有者的垃圾文件

        2) 查看用户id
            #id 用户名   //查看用户对应的id,可以查看uid 和所在组的组id  以及他所在的组

        3) 切换用户命令su
            #su [选项] 用户名
            选项:
                -: 选项只是用"-" 代表连带用户的环境变量一起切换
                -c command 命令: 仅执行一次命令,而不且换用户身份
                # su - root -c "useradd user3"    //不且换成root,但是执行useradd 命令添加user3用户;命令执行需要输入root命令

            ****注意: 普通用户切换到root用户时,一定要用# su - root; 否则就会出现部分环境变量还在普通用户那
                超级用户切到普通用户是不需要输入密码的
    --------------------------------------------------------------------------------
    7.3.5 用户组管理命令
       1) 添加用户组
           #groupadd [选项] 组名
           选项: -g GID:    指定组ID

       2) 修改用户组
           #groupmod [选项] 新组名 老组名
           选项:
                   -g GID:    修改组ID
                   -n 新组名:    修改组名
           #groupmod -n testgroup tg    //把tg组名更改为testgroup

       3) 删除用户组
           #groupdel 组名
           删除组的时候,组里不能有初始用户存在,但是附加用户没关系

       4) 把用户添加入组或从族中删除
           #gpassword 选项 组名
           选项:
               -a 用户名:     把用户加入组
               -d 用户名:    把用户从组中删除
           此命令等同于直接编辑/etc/group文件
    --------------------------------------------------------------------------------
    8.1.1 ACL权限简介与开启
        1) ACL用于解决身份不足的问题(身份是指UGO),针对的是分区,只有分区支持ACL权限,才可以开启权限

        2)查看分区ACL权限是否开启
        #df -h    //查看当前有哪些分区,df查看分区状况和容量使用情况
        #dumpe2fs -h /dev/sda3   /*查询指定分区详细文件系统信息,Default mount option: 后面有acl则表示此分区
    支持acl,一般默认是开启acl的!*/
         选项: -h 仅显示超级快中的信息,而不显示磁盘块组的详细信息

       3) 临时开启分区ACL权限
         # mount -o remount,acl /    //重新挂载根分区,并挂载加入acl权限,此为临时权限

       4) 永久开启分区ACL权限
         #vi /etc/fstab    //永久加入acl权限,fstab是系统开机自动挂载的文件,在defaults 后面加,acl.
         # mount -o remount /    //重新挂载文件系统,或重启系统,使修改生效

    --------------------------------------------------------------------------------
    8.1.2 ACL权限-查看与设定
        1) 查看ACL命令
            #getfacl 文件名    //查看acl权限
        2) 设定ACL权限
            #setfacl 选项 文件名
                选项:
                -m        设定ACL权限
                -x        删除指定的ACL权限
                -b        删除所有的ACL权限
                -d        设定默认的ACL权限
                -k        删除默认ACL权限
                -R        递归设定ACL权限

        3) 给用户设定ACL权限

            #useradd zhangsan        //添加zhangsan用户
            #useradd lisi            //添加lisi用户
            #useradd st              //添加st用户,注意,此用户既不是所有者,也不是所属组
            #groupadd test          //添加test组
            #gpasswd -a zhangsan test   //把zhangsan加入到test组
            #gpasswd -a lisi    test    //把lisi加入到test组
            #mkdir /project        //创建/project目录
            #chown root:test /project/    //更改/project目录的所有者和所属组
            #chmod 770 /project/    //更改/project/的权限
            #setfacl -m u:st:rx /project/    //给用户st赋予r-x权限,使用"u:用户名:权限"格式

            然后#ll -d /test    //可以看到目录权限后面多了个+ 2
                #getfacl /test    //可以看到st用户的权限

        4)给用户组设定ACL权限
            #groupadd test2    //创建组test2
            #setfacl -m g:test2:rwx test/        //为组test2分配ACL权限,使用"g:组名:权限"的格式

    --------------------------------------------------------------------------------
    8.1.3 ACL权限-最大有效权限和删除
        1) 最大有效权限mask
            mask是用来指定最大有效权限的.如果我给用户赋予了ACL权限,是需要和mask权限"相与(两个都为真,才为真)"才能得到用户的真正权限
        #setfacl -m m:rwx /test/    // 修改/test 的最大权限,设定mask权限使用"m:权限"的格式,最大有效权限不会影响所有者的权限

        2) 删除ACL权限
            方法1:
            #setfacl -x u:用户名 文件名    //删除指定用户的ACL权限
            #setfacl -x g:组名 文件名    //删除指定用户组的ACL权限

            方法2:
            #setfacl -b 文件名        //删除文件的所有ACL权限
    --------------------------------------------------------------------------------
    8.1.4 ACL权限-默认与递归ACL权限
        1) 递归ACL权限
            递归是父目录在设定ACL权限时,所有的现有子文件夹和子目录也会拥有相同的ACL权限.
            # setfacl -m u:用户名:权限 -R 文件名(这里是目录)    //给目录递归创建ACL权限,注意-R的位置不能错

        2) 默认ACL权限
            默认ACL权限的作用是如果给父目录设定了默认ACL权限,那么父目录中所有新建的子文件(夹)都会继承父目录中的ACL权限
            # setfacl -m d:u:用户名:权限 -R 文件名(目录名)    //d:default,未来新建的子目录也会继承该目录的ACL权限,-R 可要可不要
            # setfacl -m d:u:st:rx -R /project

    --------------------------------------------------------------------------------
    8.2.1 权限管理-文件的特殊权限 SetUID
        1) SetUID 的功能
        ( 只有可以执行的二进制程序才可能设定SUID权限
        ( 命令执行者要对该程序拥有x(执行)权限
        ( 命令执行者在执行该程序时获得该程序文件属主身份(在执行程序的过程中灵魂附体为文件的属主)
        ( SetUID权限只在该程序执行过程中有效,也就是说身份改变只在程序执行过程中有效
        ( passwd命令拥有SetUID权限,所以普通可以修改自己的密码
            #whereis passwd    //查看passwd命令的位置
            #ll /usr/bin/passwd        //在文件所有者范围内有一个s权限,就是SUID,同理,组有S权限就是 SGID,其他用户就是SBIT

           比如普通用户可以修改自己的密码,而修改密码就一定写入或者修改了/etc/shadow文件,shadow文件的权限是000,当普通用户执行
    passwd命令的时候,passwd拥有SUID权限,所以系统此时就把普通用户当成了root用户来对待,root用户对 shadow文件是拥有所有权限的.

    因此,下面的这条练会报错
        2) 设定SUID的方法
           1. #chmod 4755 文件名        //把文件的权限改为 rwsr-xr-x(4代表SUID,2代表SGID,1代表SBIT)
           2. #chmod u+s 文件名        //把文件的权限改为 rwsr-xr-x

        3) 取消SUID的方法
           1.#chmod 755 文件名        //直接取消SUID权限
           2.#chmod u-s 文件名        //直接取消SUID权限
        取消SUID后,重新赋予SUID,再查看文件权限的时候s变成了S,大写的S其实是报错,表示是这个权限的不能运行
    原因是该文件的权限是644,普通用户对此文件没有x(执行)权限

        4) 危险的SUID
         ( 关键目录应严格控制写权限,比如"/","/usr"等
         ( 用户的密码设置要严格遵守密码三原则
         ( 对系统中默认应该具有SetUID权限的文件做一列表,定时检查有没有这之外的文件被设置了SetUID权限
    --------------------------------------------------------------------------------
    8.2.2 SetGID
        1) SetGID针对文件的作用
         ( 只有可以执行的二进制程序才可能设定SGID权限
         ( 命令执行者要对该程序拥有x(执行)权限
         ( 命令执行者在执行该程序时,组身份自动升级为该程序文件属组
         ( SetUID权限同样只在该程序执行过程中有效,也就是说组身份改变只在程序执行过程中有效
        此命令用的不多, 比如locate,查找命令

        2) SetGID针对目录的作用
         ( 普通用户必须对此目录拥有r和x权限,才能进入此目录
         ( 普通用户在此目录中的有效组会变成此目录的属组
         ( 若普通用户对此目录拥有w权限是,新建的文件的默认属组是这个目录的属组

        3) 设定SetGID
           #chmod 2755 文件名    //2代表SGID,给文件或者目录设定SGID
           #chmod g+s 文件名    //给文件或者目录设定SGID

        4) 取消SetGID
            #chmod 755 文件名    //取消SetGID
            #chmod g-s 文件名    //取消SetGID

    --------------------------------------------------------------------------------
    8.2.2 L文件特殊权限-Sticky BIT(粘着位权限)
        1) SBIT粘着位作用
            ( 粘着位目前只对目录有效
            ( 普通用户对该目录拥有W和X权限,即普通用户可以在此目录拥有写入权限
            ( 如果没有粘着位,因为普通用户拥有W权限,所以可以删除此目录下所有文件,
        包括其他用户建立的文件.一旦赋予了粘着位,除了root可以删除所有文件,普通用户就算
        拥有w权限,也只能删除自己简历的文件,但是不能删除其他用户建立的文件.//比如
        /tmp 目录的权限是777, 在/tmp目录没有粘着位的情况下,user2可以删除user1在/tmp目录下
        创建的文件;如果有了粘着位,user2只能删除自己创建的文件,而不能删除user1创建的文件.
        // 表示此目录被赋予SBIT粘着位

        2) 设置和取消粘着位
            ( 设置粘着位
                ● chmod 1755 目录名    //设置粘着位
                ● chmod o+t 目录名    //另一种方法设置粘着位
            ( 取消粘着位
                ● chmod 777 目录名    //取消目录的粘着位
                ● chmod o-t 目录名    //另一种取消粘着位的方法
    --------------------------------------------------------------------------------
    8.3.1 文件系统属性权限-chattr (change attribute) PS:此命令针对root用户也是有效的
        1) 命令格式
            #chattr [+-=][选项] 文件或目录名
                +: 增加权限
                -: 删除权限
                =: 赋予某权限
                    选项:
                        -i:     如果对文件设置i属性,那么不允许对文件进行删除,改名;相当于把文件给锁定了!比 a选项更严格
                  也不能添加和修改数据;如果对目录设置i属性,那么只能修改目录下文件的额数据,但不允许建立和删除文件.
                        -a:  如果对文件设置a属性, 那么只能在文件中增加数据, 但是不能删除也不能修改数据; 如果对目录设置a属性,
                   那么只允许在目录中建立和修改文件,但是不允许删除;相对i选项要宽松点
            2) 查看文件系统属性
                #lsattr 选项 文件名
                    选项:
                        -a 显示所有文件和目录
                        -d 若目标是目录,仅列出目录本身的属性,而不是子文件的

        当给文件追加+a属性后, 只能通过#echo 命令追加内容, vi/vim 都无法修改或者删除文件内容如下图;目录赋予+a属性.
    --------------------------------------------------------------------------------
    8.4 系统命令权限-sudo权限
        1) sudo 权限
            ( root 把本来只能超级用户执行的命令赋予普通用户来执行
            ( sudo的操作多想是系统命令

        2) sudo使用
        #visudo    //实际修改的是/etc/sudoers文件
        root ALL=(ALL)    ALL    //用户名 被管理主机的地址(linux服务器的IP,或者说是远程控制的IP)=(可是用的身份)    授权命令(绝对路径)
        例子:
        aphey  192.168.1.118=/sbin/shutdown -r now  //表示在192.168.1.118这个机器上,我可以用aphey这个用户执行
        $ sudo /sbin/shutdown -r now 这个命令
        #%wheel    ALL=(ALL)    ALL    //%组名 被管理主机的地址(linux服务器的IP)=(可使用的身份)    授权命令(绝对路径)

        3) 授权sc用户可以重启服务器
        #visudo
        sc    ALL=/sbin/shutdown -r now    //允许sc用户在本机上重启服务器,注意,命令越详细用户的权限越小


        4) 普通用户执行sudo赋予的命令
        #su - user1
        $sudo -l    //查看可用的sudo命令
        $sudo /sbin/shutdown -r now    //普通用户user1执行sudo赋予的命令
    --------------------------------------------------------------------------------
    9.1 文件系统管理-回顾分区和文件系统
        1） 分区类型
            ( 主分区：最多只能分4个
            ( 扩展分区： 只能有1个，也算作主分区的一种，也就是说主分区加扩展分区最多有4个。但是扩展分区不能存储数据
            和格式化，必须再划分成逻辑分区才能使用
            ( 逻辑分区：逻辑分区是在扩展分区中划分的，如果是IDE硬盘，Linux最多支持59个逻辑分区，
            如果是SCSI硬盘,Linux最多支持11个逻辑分区
        分区设备名是固定的，扩展分区肯定是从sda5开始，需记住！

        2）文件系统
         ( ext2: 是ext文件系统的升级版本， Redhat Linux7.2 版本以前的系统默认都是ext2文件系统。KB
        1993年发布，最大支持16TB的分区和最大2TB的文件（1TB=1024GB=1024*1024KB）
         ( ext3: 是ext2文件系统的升级版本，最大的区别就是带日志功能，以在系统突然停止时提高文件系统的可靠性。
        支持最大16TB的分区和最大2TB的文件
         ( ext4: 是ext3文件系统的升级版本。ext4在性能,伸缩性和可靠性方面进行了大量改进.ext4的变化可以说是翻天覆地，
        比如向下兼容ext3，最大1EB文件系统和16TB文件，无线数量子目录，Extents的连续数据块概念，多块分配，延迟分配，
        持久预分配，快速FSCK，日志校验，无日志模式，在线碎片管理，inode增强，默认启用barrier等。是centos6.3默认文件系统
        （1EB=1024PB=1024*1024TB）
    --------------------------------------------------------------------------------
    9.2 文件系统常用命令
        df,du,fsck,dumpe2fs
    9.2.1
        df命令，du命令，fsck命令和dumpe2fs
        1) 文件系统查看命令df
            #df 【选项】【挂载点】
            选项：
                -a 显示所有文件系统信息，包括特殊文件系统，如/proc，/sysfs
                -h 使用习惯单位显示容量，如KB,MB或GB等 //habit
                -T 显示文件系统类型    //Type
                -m 以MB为单位显示容量
                -k 以KB为单位显示容量。 默认就是以KB为单位
        2) 统计目录或文件大小
            #du 【选项】 【目录或文件名】
            选项：
                -a 显示每个字文件的磁盘占用量。默认只统计子目录的磁盘占用量
                -h 使用习惯单位显示磁盘占用量，如KB，MB或GB等    //humanization
                -s 统计总占用量，而不列出子目录和字文件的占用量    //statistics
        du命令和df命令的区别：
        ( df命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（
        最常见的就是文件已经删除，但是程序并没有释放空间）
        ( du命令是面向文件的，智慧计算文件或者目录占用的空间
        3） 文件系统修复命令fsck(系统会自动运行，了解即可，手动运行可能会出错)
            #fsck 【选项】分区设备文件名
            选项：
                -a: 不用显示用户提示，自动修复文件系统
                -y: 自动修复，和-a 作用一致，不过有些文件系统只支持-y
        4） 显示磁盘状态命令(了解即可)
            #dumpe2fs 分区设备文件名
    --------------------------------------------------------------------------------
    9.2.2 挂载命令
        1） 查询与自动挂载
            #mount [-l]    //查询系统中已经挂在的设备，-l会显示卷标名称
            #mount -a    //依据配置文件/etc/fstab的内容，自动挂载
        2） 挂在命令格式
            #mout 【-t 文件系统】 【-L 卷表名】【-o 特殊选项】 设备文件名 挂载点
            选项
                -t 文件系统： 加入文件系统类型来制定挂在的类型，可以ext3,ext4，iso9660（光驱）等文件系统
                -L 卷表明： 挂载制定卷标的分区，而不是安装设备文件名挂载
                -o 特殊选项：可以指定挂载的额外选项
    --------------------------------------------------------------------------------
    9.2.3 文件系统常用命令-挂载光盘和U盘
        1） 挂载光盘
            #mkdir /mnt/cdrom    //建立挂载点
            #mount -t iso9660 /dev/cdrom /mntcdrom (#mount /dev/sr0 /mntcdrom)     //挂载光盘

        2) 卸载命令
            #umount 设备文件名或者挂载点    //卸载光盘

        3) 挂载U盘
            #fdisk -l    //查看U盘设备文件名
            #mount -t vfat /dev/sdb1 /mnt/usb/    //挂载U盘,(vfat----fat32; fat---fat16);
         注意:linux默认是不支持NTFS文件系统的
        4) 卸载U盘
            #umount /mnt/usb/        //卸载U盘
    --------------------------------------------------------------------------------
    9.2.4    支持NTFS文件系统
        方法一:  重新编译内核(用的特别少,不推荐)
        方法二:  利用第三方软件 如NTFS-3G插件
            1) 下载地址: http://www.tuxera.com/community/ntfs-3g-download/ ,并传到Linux系统
        2) 安装NTFS-3G
        3) 使用: #mount -t nfts-3g 分区设备文件名 挂载点
        4) 卸载U盘
          #umount /mnt/usb/        //卸载移动硬盘
    --------------------------------------------------------------------------------
    9.3.1 fdisk分区---分区过程
            1) 添加新硬盘(先断开电源)

            2) 查看新硬盘
                #fdisk -l    //查看新硬盘

        3) 使用fdisk命令分区
        #fdisk /dev/sdb    //为新硬盘sdb进行分区操作;注意分区完成后必须按w 保存退出

        4) 分区完成后,系统会提示重启linux系统,我们可以用#partprobe强制让系统重新读取分区表信息

        5) 格式化分区
            #mkfs -t ext4 /dev/sdb1    //格式化分区sdb1.
            #mkfs -t ext4 /dev/sdb5    //格式化分区sdb5.

        6) 建立挂载点并挂载
            #mkdir /disk1    //创建一个空目录disk1
            #mount /dev/sdb1 /disk1/    //挂在sdb1 到 disk1

        以上的挂在方法在电脑重启后会失效
    --------------------------------------------------------------------------------
    9.3.2 fdisk分区---自动挂载与fstab文件修复
        1) /etc/fstab文件

             第一字段: 分区设备文件名或UUID(硬盘通用唯一识别码) 可以通过 # dumpe2fs /dev/sdb1 查看 sdb1的UUID
                * 也可以不写UUID,而写 /dev/sdb1
             第二字段: 挂载点
             第三字段: 文件系统名称
             第四字段: 挂载参数
             第五字段: 制定分区是否被dump备份,0代表不备份,1代表每天备份,2代表不定期备份(每个分区目录下的lost+found文件夹就是备份目录)
             第六字段: 制定分区是否被fsck检测,0代表不检测,其他数字代表检测的优先级,那么当然1的优先级比2高
        2) 分区自动挂载
            # vi /etc/fstab
            ...省略部分输出...
            /dev/sdb1    /disk1    ext4    defaults    1 2

        万一/etc/fstab 写错,系统就会崩溃,没法启动,为了保险
        执行 # mount -a     //依据 /etc/fstab的内容,自动挂载,有错的话就会报错,没错的话,就没有提示
        真的崩溃了的话,可以在开机的时候可以通过输入root密码后运行命令进行修复.
         # mount -o remount,rw /   然后在用 # vim /etc/fstab 进行修复.再重启就不会报错了        //前提是根分区的配置没问题
    --------------------------------------------------------------------------------
    9.4 分配swap分区
        1) free命令
           #free    //查看内存与swap分区使用状况
            cached (缓存): 是指把读取出来的数据保存在内存当中,再次读取时,不用读取硬盘而直接从内存中读取,加速了数据的读取过程
            buffer (缓冲): 是指在写入数据时,先把分散的写入操作保存到内存当中,当达到一定程度再集中写入硬盘,减少了磁盘碎片和
        硬盘的反复寻道,加速了数据的写入过程


        2) 新建swap分区
            # fdisk /dev/sdb    //新建分区,别忘记把分区ID改为82
            # parprobe  //让系统重新扫描一下分区列表

        3) 格式化
            #mkswap /dev/sdb6

        4)加入swap分区
            # swapon /dev/sdb6    //加入swap分区
            # swapoff /dev/sdb6    //取消swap分区

        5) swap分区开机自动挂载
           #vi /etc/fstab    //编辑/etc/fstab文件
            /dev/sdb6    swap    swap    defults    0    0
           #mount -a    //挂载一下
    --------------------------------------------------------------------------------
    10.1 shell 基础
        1) Shell 是什么
          ( Shell是一个命令行解释器,它为用户提供了一个向Linux内核发送请求一边运行程序的界面系统级程序,
        用户可以用Shell来启动、挂起、停止甚至是编写一些程序。
            内核 管理硬件；我们通过外层应用输入命令，内核并不能识别这些命令，shell就是命令解释器，把命令
        翻译为机器能够识别的机器语言，再把机器语言转换成人类能够看懂的命令。 Shell也就是我们平时输入命令
        的交互界面。
          ( Shell还是一个功能相当强大的编程语言，易编写，易调用，灵活性较强。Shell是解释执行的脚本语言，在
        Shell中可以直接调用Linux系统命令。

        2）Shell的分类
           ( Bourne Shell： 从1979年起Unix就开始使用　Bourne Shell,Bourne Shell的主文件名为 sh。

           ( C Shell： C Shell主要是在BSD版的Unix系统中使用，其语法和C语言相似而得名
           ( Shell的两种主要语法类型有Bourne和C,这两种语法彼此不兼容。Bourne家族主要包括sh、
        ksh、Bash、Bash、psh、zsh；C家族主要包括：csh、tcsh
           ( Bash：Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell.

        3） Linux支持的Shell
          ( /etc/shells
            #sh    //输入shell的名称即可切换

    --------------------------------------------------------------------------------
    10.2 脚本执行方式
        1）echo输出命令
        #echo 【选项】 【输出内容】
        //如果输出的内容中有空格，那么输出内容得用“”扩上，而且如果内容里有感叹号，就要把“”换成‘’。
        选项：
            -e: 支持反斜线控制的字符转换(支持转转义)
        反斜线控制符及作用
        控制字符        作用
        \\            输出\本身,第一个\是转义符
        \a            输出警告音
        \b            退格键，也就是向左删除键
        \c            取消输出航模的换行符。和“-n”的选项一致
        \e            Escape键
        \f            换页符
        \n            换行符
        \r            回车键
        \t            制表符，也就是tab键
        \v            垂直制表符
        \0nnn        按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数
        \xhh        按照十六进制ASCII码表输出字符，其中hh是两位十六进制数
        #echo -e "\e[1;31m abcd \e[0m"  // \e[1； 开启颜色输出,31m颜色代码,可选颜色：31m-37m,\e[0m 结束颜色输出
    --------------------------------------------------------------------------------
   10.3.1 Bash的基本功能-历史命令与补全
       1） 历史命令
           #history [选项] [历史命令保存文件]
           选项：
               -c：    清空历史命令
               -w:     把缓存中的历史命令写入历史命令保护文件    /root/.bash_history
          历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改，在/etc/profile中修改HISTSIZE=的数值即可。
           历史命令的调用
           ( 使用上、下箭头调用以前的历史命令
           ( 使用“!n”重复执行第n条例是命令
           ( 使用“!!”重复执行上一条命令
           ( 使用“!字串”重复执行最后一条以该字串开头的命令
       2） 命令与文件补全
       ( 在bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或者文件时，按“TAB”键就会自动进行补全
    --------------------------------------------------------------------------------
   10.3.2    bash基本功能-别名与快捷键
       1） 命令别名
           #alias 别名='原命令'    //设定命令别名
           #alias                //查询命令别名


        命令执行时顺序
           1. 第一顺位执行用绝对路径或相对路径执行的命令
           2. 第二顺位执行别名
           3. 第三顺位执行Bash的内部命令
           4. 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令
               #echo $PATH        //调用PATH 变量内容，主要要想调用变量的值，需要在变量前面加"$"
         让别名永久生效
           # vi /root/.bashrc        //编辑别名文件
              在里面添加 alias vi='vim'        //使vi=vim永久生效
           # source /root/.bashrc   //让别名立刻生效
          删除别名
           unalias 别名        //删除别名

        2）Bash常用快捷键

                一、编辑命令

                Ctrl + a ：移到命令行首
                Ctrl + e ：移到命令行尾
                Ctrl + f ：按字符前移（右向）
                Ctrl + b ：按字符后移（左向）
                Alt + f ：按单词前移（右向）
                Alt + b ：按单词后移（左向）
                Ctrl + xx：在命令行首和光标之间移动
                Ctrl + u ：从光标处删除至命令行首
                Ctrl + k ：从光标处删除至命令行尾
                Ctrl + w ：从光标处删除至字首
                Alt + d ：从光标处删除至字尾
                Ctrl + d ：删除光标处的字符
                Ctrl + h ：删除光标前的字符
                Ctrl + y ：粘贴至光标后
                Alt + c ：从光标处更改为首字母大写的单词
                Alt + u ：从光标处更改为全部大写的单词
                Alt + l ：从光标处更改为全部小写的单词
                Ctrl + t ：交换光标处和之前的字符
                Alt + t ：交换光标处和之前的单词
                Alt + Backspace：与 Ctrl + w 相同类似，分隔符有些差别 [感谢 rezilla 指正]

                二、控制命令

                Ctrl + l：清屏
                Ctrl + o：执行当前命令，并选择上一条命令
                Ctrl + s：阻止屏幕输出
                Ctrl + q：允许屏幕输出
                Ctrl + c：终止命令
                Ctrl + z：挂起命令

                三、重新执行命令

                Ctrl + r：逆向搜索命令历史
                Ctrl + g：从历史搜索模式退出
                Ctrl + p：历史中的上一条命令
                Ctrl + n：历史中的下一条命令
                Alt + .：使用上一条命令的最后一个参数

                四、Bang (!) 命令

                !!：执行上一条命令
                !blah：执行最近的以 blah 开头的命令，如 !ls
                !blah:p：仅打印输出，而不执行
                !$：上一条命令的最后一个参数，与 Alt + . 相同
                !$:p：打印输出 !$ 的内容
                !*：上一条命令的所有参数
                !*:p：打印输出 !* 的内容
                ^blah：删除上一条命令中的 blah
                ^blah^foo：将上一条命令中的 blah 替换为 foo
                ^blah^foo^：将上一条命令中所有的 blah 都替换为 foo
    --------------------------------------------------------------------------------
   10.3.3 bash基本功能-输入输出重定向
       标准输出重定向：原来应该输出到输出设备，但是现在设定为输出到文件
        方法： 命令 > 文件    //以覆盖的方式，把命令的正确输出输出到指定的文件或设备中
              命令 >> 文件    //以追加的方式,把命令的正确输出输出到指定的文件或设备当中
              错误命令 2> 文件    //以覆盖的方式，把命令的错误输出输出到指定的文件或设备中
              错误命令 2>> 文件    //以追加的方式,把命令的错误输出输出到指定的文件或设备当中
             命令 > 文件 2 >&1    //以覆盖的方式，把正确输出和错误输出都保存到同一个文件中
             命令 >> 文件 2 >&1    //以追加的方式，把正确输出和错误输出都保存到同一个文件中
               命令 &>文件    //以覆盖的方式，把正确输出和错误输出都保存到同一个文件中
               命令 &>>文件    //以追加的方式，把正确输出和错误输出都保存到同一个文件中
           命令>>文件1 2>>文件2    //把正确的输出追加到文件1,把错误的输出追加到文件2
           /dev/null 此文件相当于是linux的垃圾箱，当shell脚本中有无意义输出的时候可以考虑把那些输出输出到此文件中


       输入重定向：把文件作为输入来源；用的不多，一般是为RPM包打补丁
           #wc [选项] [文件名]
           选项：
           -c:    统计字节数
           -w:    统计单词数
           -l:    统计行数
    --------------------------------------------------------------------------------
    10.3.4 Bash基本功能-多命令顺序执行和管道符
        1）多命令顺序执行
            多命令执行符        格式                作用
                ；        命令1；命令2        多个命令顺序执行，命令之间没任何逻辑联系
               &&         命令1&&命令2        逻辑与； 当命令1正确执行，则命令2才执行，1不正确，则2不会执行
               ||         命令1||命令2        逻辑或； 当命令1执行不正确，则命令2才执行，1正确执行，则2不会执行

           # dd if=输入文件 of=输出文件 bs=字节数 count=个数
            选项：
                if=输入文件        指定源文件或源设备
                of=输出文件        指定目标文件或目标设备
                bs=字节数          指定一次输入/输出多少字节，即把这些字节看作一个数据块
                count=个数         指定输入/输出多少个数据块
           Example：# date；dd if=/dev/zero of=/root/tesfile bs=1k count=100000;date
            //dd 命令是磁盘复制或者数据复制的命令；通俗来讲就是磁盘对拷；此命令的意思是，从/dev/zero
            中拷一个100M的文件到/root/testfile,两个date可以显示拷贝过程花的时间

        逻辑与：比较常用的就是软件安装的 ./configg && make && make install

        逻辑与和逻辑或混合使用：#命令 && echo yes || echo no    //当命令正确时，显示yes，否则 显示no


        2） 管道符
            命令格式：#命令1 | 命令2    //命令1的正确输出作为命令2的操作对象；

        #grep [选项] “搜索内容” 文件名
            选项：
                -i: 忽略大小写
                -n: 输出行号
                -v：反向查找
                --color=auto 搜索出的关键字用颜色显示
    --------------------------------------------------------------------------------
    10.3.5    Bash的基本功能---通配符和其他特殊符号
        1） 通配符                    作用
            ？                匹配一个任意字符
            *                匹配0个或任意多个任意字符,也就是可以匹配任何内容
           [ ]                匹配中括号中任意一个字符.如:[abc]代表一定匹配一个字符,或者是a,或者是b，或者是c
           [-]                匹配中括号中任意一个字符,-代表一个范围.如:[a-z]代表匹配一个小写字母
           [^]                逻辑非,表示匹配不是中括号内的一个字符.如:[^0-9]代表匹配一个不是数字的字符

        2）Bash中其他特殊符号
            符号                    作用
            ''                    单引号,在单引号中特殊符号都没有特殊含义,  如"$"和"`"(反引号)都没有特殊意义
            ""                    双引号,在双引号中特殊符号都没有特殊含义,但是"$" "`" 和"\"是例外，拥有“
                                  调用变量”、“引用命令”和“转义符”的特殊含义。
            ``                    反引号.反引号括起来的内容是系统命令,在Bash中会先执行它。和$()作用一样，不过
                                  推荐使用$()，因为反引号非常容易看错
            $()                   和反引号作用一样，用来引用系统命令
            #                     在Shell脚本中，#开头的行代表注释。
            $                     用于调用变量的值,如需要调用变量name的值时，需要用$name的方式得到变量的值
            \                     转义符,跟在\后的特殊符号将失去特殊含义,变为普通字符,如\$将输出“$”,而不是
                                  当作变量引用
    --------------------------------------------------------------------------------
    10.4.1    Bash变量---用户自定义变量(也叫本地变量)
        Bash变量类型：
            ( 用户自定义变量
            ( 环境变量
            ( 位置参数变量
            ( 预定义变量
        1) 什么是变量
            变量是计算机内存的单元，其中存放的值可以改变。当Shell脚本需要保存一些信息时，如一个文件名或是一个数字，就把它存放在一个变量中。
        每个变量有一个名字，所以很容易引用它。使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息
        2) 变量设置规则
            ( 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如果变量名是“2name”则是错误的。
            ( 在Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。
            ( 变量用等号连接值，等号左右两侧不能有空格。
            ( 变量的值如果有空格,需要使用单引号或双引号包括.
            ( 在变量的值中，可以使用'\'转义符.
            ( 如果需要增加变量的值,那么可以引进变量值的叠加.不过变量需要用双引号包含“$变量名”或用${变量名}包含.
            ( 如果是把命令的结果作为变量值赋予变量，则需要使用反引号或者$()包含命令.

            ( 环境变量名建议大写,便于区分.
        3) 变量分类
            ( 用户自定义变量    //变量名和值都可以自己改
            ( 环境变量:这种变量主要保存的是和系统操作环境相关的数据    //可以新增环境变量
            ( 位置参数变量:这种变量主要用来向脚本当中传递参数或数据的,变量名不能自定义变量作用是固定的
            //变量名称不能改,值可以修改,位置参数变量其实是下面预定义变量的一种
            ( 预定义变量: 是Bash中已经定义好的变量,变量名不能自定义,变量作用也是固定的
        4) 本地变量
            ( 变量定义
                #name="shen chao"
            ( 变量叠加
                #aa=123
                #aa="$aa"456
                #aa=${aa}789

            ( 变量调用
                #echo $name    //调用变量
            ( 变量查看
                #set        //查看所有的变量
            ( 变量删除
                #unset name     //删除变量
    --------------------------------------------------------------------------------
    10.4.2 Bash变量-环境变量
        1) 环境变量是什么
            ( 用户自定义变量只在当前的Shell中生效,而环境变量会在当前Shell和这个Shell的所有子Shell当中生效.
         如果把环境变量写入相应的配置文件,那么这个环境变量就会在所有的Shell中生效
        2) 设置环境变量
           #export 变量名=变量值    //申明变量
           #env            //查询变量,是专门用来查看环境变量的,set是查看所有变量的,包括环境变量
           #unset 变量名    //删除变量
        3) 系统常见环境变量
            ( PATH: 系统查找命令的路径
             #echo $PATH
            ( PATH="$PATH":/root/sh    //PATH变量叠加,再在/root/sh文件夹里写脚本就可以直接运行,而不用输入完整路径
            ( PS1:定义系统提示符的变量   如默认的 [root@localhost ~]#
               #echo PS1   //可以查看默认的排版
               \d: 显示日期,格式为"星期 月 日"
               \h: 显示简写主机名.默认主机名"localhost"
               \t: 显示24小时制时间,格式为"HH:MM:SS"
               \T: 显示12小时制时间,格式为"HH:MM:SS"
               \A: 显示24小时制时间,格式为"HH:MM"
               \u: 显示当前用户名
               \w: 显示当前所在目录的完整名称
               \W: 显示显示当前所在目录的最后一个目录
               \@: 显示当前时间
               \#: 执行的第几个命令
               \$: 提示符.如果是root用户,会显示提示符为"#",如果是普通用户,会显示提示符为"$"
    --------------------------------------------------------------------------------
    10.4.3 Bash变量--位置参数变量
        1) 位置参数变量
            位置参数变量                作用
                $n                n为数字,$0代表命令本身,$1-$9代表第一道第九个参数,十以上的参数需要用大括号包含,如${10}.
                $*                这个变量代表命令行中所有的参数,$*把所有的参数看成一个整体.
                $@                这个变量也代表命令行中所有的参数,不过$@把每个参数区分对待.
                $#                这个变量代表命令行中所有参数的个数.
    --------------------------------------------------------------------------------
    10.4.4 Bash变量--欲定义变量
        1) 预定义变量
            预定义变量                作用
                $?                最后一次执行的命令的返回状态.吐过这个变量的值为0,证明上一个命令正确执行;如果这个变量的值为非0(具体是哪个数,
                                由命令自己来决定),则证明上一个命令执行不正确了
                $$                当前进程的进程号(PID)
                $!                后台运行的最后一个进程的进程号(PID)

        2) 接受键盘输入
            # read [选项] [变量名]
                选项:
                    -p "提示消息": 在等待read输入时,输出提示信息
                    -t 秒数: read命令会一直等待用户输入,使用此选项可以制定等待时间
                    -n 字符数: read命令只接受制定的字符数,就会执行,不用按回车
                    -s: 隐藏输入的数据,适用于机密信息的输入

    --------------------------------------------------------------------------------
    10.5.1 Bash变量-数值运算和运算符
        1) declare 声明变量类型
            # declare [+/-] [选项] 变量名    //
            选项:
                -: 给变量设定类型属性
                +: 取消变量的类型属性
                -i: 将变量声明为整数型(integer)
                -x: 将变量声明为环境变量
                -p: 显示制定变量的被声明的类型

        2) 数值运算---方法1
            #aa=11
            #bb=22
            //给变量aa和bb赋值
            #declare -i cc=$aa+$bb
            方法2: expr或let数值运算工具    //expr:expression  表达式
            #aa=11
            #bb=22
            #dd=$(expr$aa + $bb)    //dd的值是aa和bb的和,注意"+"左右两侧必须有空格
            方法3: "$(运算式)"或"$[运算式]"
            #aa=11
            #bb=22
            #ff=$(($aa+$bb))        //单小括号表示里面的是系统命令;双小括号表示的是数值运算
            #gg=$[$aa+$bb]

        3) 运算符
            //优先级数值越大,优先级越高,和数学里一致
            优先级        运算符            说明
            13            -,+            单目负,单目正
            12            !,`            逻辑非,按位取反或补码
            11            *,/,%          乘,除,取余
            10            +,-            加,减
            9            <<,>>            按位左移,按位右移
            8            <=,>=,<,>        小于等于,大于等于,小于,大于
            7            ==,!=            等于,不等于
            6            &                按位与
            5            ^                按位异或
            4            |                按位或
            3            &&               逻辑与
            2            ||               逻辑或
            1        =,+=,-=,*=,/=,%=     赋值,运算且赋值
                     &=,^=,|=,<<=,>>=
    --------------------------------------------------------------------------------
  10.6.1
      环境变量配置文件简介
      下面两个命令的功能是一样的,就是当配置文件需要重启才能生效时,可以用下面的命令,强制使之生效,常见的 有# source /etc/profile
      # source 配置文件
      # . 配置文件
      环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量,比如 PATH、HISTSIZE、PS1、HOSTNAME等默认环境变量
      系统当中主要有以下五类：
      A) /etc/profile
      B) /etc/profile.d/*.sh
      C) ~/.bash_profile
      D) ~/.bashrc
      E) /etc/bashrc
  10.6.2 环境变量配置文件
  开机读取顺序图:
  /etc/profile的作用:
  1) USER变量
  2) LOGNAME变量
  3) MAIL变量
  4) PATH变量
  5) HOSTNAME变量
  6) HISTSIZE变量
  7) umask
  8) 调用/etc/profile.d/*.sh文件
  PS: 如果我把别名写在/etc/profile(默认写在~/.bashrc)里,那么这些别名对所有用户都生效.在上图中,越往后定义的变量优先级越高.
    --------------------------------------------------------------------------------
  10.6.3其他配置文件和登录信息
  1)~/.bash_logout  //注销时生效的环境变量配置文件
  2)~/bash_history    //历史命令,都保存在这个文件当中
  3) /etc/issue    //本地终端的欢迎信息
      转义符        作用
      \d        显示当前系统日期
      \s        显示操作系统名称
      \l        显示登录的终端号(只对linux本机有用,远程无用),比较常用
      \m        显示硬件体系结构
      \n        显示主机名
      \o        显示域名
      \r        显示内核版本
      \t        显示当前系统时间
      \u        显示当前登录用户的序列号
  /etc/issue.net    //远程终端欢迎界面
      注意: 1) 转义符在/etc/issue.net中不能使用
           2) 是否显示此欢迎信息,由ssh的配置文件/etc/ssh/ssh_config决定,加入"Banner /etc/issue.net"行才能显示(记得重启ssh服务)
  /etc/motd    //messagge of the day   也可以理解为欢迎信息,即对本地终端有效,也对远程终端有效;这个是登录之后的欢迎信息,/etc/issue 和 /etc/issue.net是登录前的欢迎信息
    --------------------------------------------------------------------------------
    11.1 正则表达式
    正则表达式和通配符
        正则表达式用来在文件中匹配符合条件的字符串,正则是包含匹配.grep、awk、sed等命令可以支持正则表达式。
        通配符是用来匹配符合条件的文件令，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配了。
    基础正则表达式(去网上搜索扩展正则表达式)
    元素符                作用
    *            前一个字符匹配0次或任意多次. 如 a* 表示a 出现0次或者n多次.
    .            匹配除了换行符外任意一个字符.
    ^            匹配行首.如: ^hello 会匹配以hello开头的行.
    $            匹配行尾.如; hello$ 会匹配以hello结尾的行.
    []           匹配中括号中置顶的任意一个字符,指配配一个字符.
                 如: [aoeiu] 匹配任意一个原因字母,[0-9]匹配任意一个数字,[a-z][0-9]匹配小写字母和一位数字构成的两位字符
    [^]          取反,匹配除中括号的字符以外的任意一个字符.如[^0-9]匹配任意一个非数字字符,[^a-z]匹配任意一位非小写字母的字符.
    \            转义符.用于取消特殊符号的含义.
    \{n\}        表示其前面的字符敲好出现n次.如[0-9]\{4\}匹配4位数字,[1][3-8][0-9]\{9\}匹配手机号码.
    \{n,\}       表示其前面的字符出现不小于n次.如[0-9]\{2,\}表示两位及两位以上的数字.
    \{n,m\}      表示其前面的字符至少出现n次,最多出现m次,如[a-z]\{6,8\},匹配6到8位的小写字母
    举例:
    # vi test_rule.txt
    Mr. Li Ming said:
    he was the honest man in LampBrother.
    123 despise him.

    But since Mr. shen Chao came,
    he never saaaid those words.
    555nice!

    because,actuaaaally,
    Mr. Shen Chao is the most honest man!

    Later,Mr Li Ming soid his hot body.

    "*"前面一个字符匹配0次,或任意多次
    # grep "a*" test_rule.txt    //匹配所有内容,包括空白行
    # grep "a**" test_rule.txt    //匹配至少含有一个a的行
    # grep "aaa*" test_rule.txt    //匹配至少包含两个连续a的字符串
    # grep "aaaaa*" test_rule.txt    //匹配至少包含四个连续a的字符串

    "."匹配除了换行符以外任意一个字符
    # grep "s..d" test_rule.txt     //会匹配在s和d这俩字母之间一定有两个字符的单词
    # grep "s.*d" test_rule.txt     //会匹配在s和d字母之间有任意字符(sd字段也会被匹配)
    # grep ".*" test_rule.txt    //匹配所有内容

    "^"匹配行首,"$"匹配行尾
    # grep "^M" test_rule.txt    //匹配以"M"开头的行
    # grep "n$" test_rule.txt   //匹配以"n"结尾的行
    # grep -n "^$" test_rule.txt    //匹配空白行

    "[]"匹配中括号中置顶的任意一个字符,只匹配一个字符
    # grep "s[ao]id" test_rule.txt    //匹配s和i字母中间,要么是a,要么是o
    # grep "[0-9]" test_rule.txt    //匹配任意一个数字
    # grep "^[a-z]" test_rule.txt    //匹配小写字母开头的行

    "[^]" 匹配除中括号的字符以外的任意一个字符
    # grep "^[^a-z]" test_rule.txt    //匹配不用小写字母开头的行
    # grep "^[^a-zA-Z]" test_file.txt    //匹配不用字母开头的行

    "\" 转义符
    # grep "\.&" test_rule.txt    //匹配以"."结尾的行

    "\{n\}" 表示前面的字符恰好出现n次
    # grep "a\{3\}" test_rule.txt    //匹配a字母连续出现三次的字符串
    # grep "[0-9]\{3\}" test_rule.txt    //匹配包含连续的三个数字的字符串

    "\{n,\}" 表示其前面的字符出现不小于n次
    # grep "^[0-9]\{3,\}[a-z]" test_rule.txt    //匹配最少用连续三个数字开头的行

    "\{n,m\}"匹配其前面的字符至少出现n次,最多出现m次
    # grep "sa\{1,3\}i" test_rule.txt    //匹配在字母s和字母i之间至少有一个a,最多有三个a
    --------------------------------------------------------------------------------
    11.2.1 cut 字段提取命令
    grep 在文件当中提取符合条件的行
    cut 和awk 来提取列
    # cut [选项] 文件名
    选项: -f 列号: 提取第几列
         -d 分隔符:  返照置顶分隔符分割列 delimit
    按列
    # vi student.txt

    ID      Name    Gender  Mark
    1       Liming  M       86
    2       Sc      M       90
    3       Gao     M       83

    [root@localhost tmp]# cut -f 2 student.txt
    Name
    Liming
    Sc
    Gao
    [root@localhost tmp]# cut -f 2,4 student.txt
    Name    Mark
    Liming    86
    Sc    90
    Gao    83
    默认分隔符是"tab键的制表符",/etc/passwd等文件用的分隔符是":"
    [root@localhost tmp]# cut -d ":" -f 1,3 /etc/passwd
    root:0
    bin:1
    daemon:2
    adm:3
    lp:4
    sync:5
    shutdown:6
    halt:7
    mail:8
    uucp:10
    operator:11
    games:12
    gopher:13
    ftp:14
    nobody:99
    dbus:81
    vcsa:69
    rpc:32
    abrt:173
    rpcuser:29
    nfsnobody:65534
    haldaemon:68
    ntp:38
    saslauth:499
    postfix:89
    sshd:74
    tcpdump:72
    oprofile:16
    cut命令很简单,在平时有什么用?
    假如我们新建了100个用户,现在要提取这100个用户!
    [root@localhost tmp]# useradd user1
    [root@localhost tmp]# useradd user2
    [root@localhost tmp]# useradd user3
    [root@localhost tmp]# cat /etc/passwd |grep /bin/bash |grep -v root |cut -d ":" -f 1
                          查看/etc/passwd  | 查找shell 为/bin/bash 的列| 取反 排除root,不能删除root用户| 再以":"为分隔符,选取第一列
    user1
    user2
    user3
    注意 df 命令的第一field 和第二field之间的分隔符是n个空格.所以这时候我们就可以用更复杂的awk. 一般比较规则的 能用cut的 就用cut
    --------------------------------------------------------------------------------
    11.2.2 字符截取命令 printf
    printf 是最常用在 awk 列提取命令当中的标准输出格式
    命令格式  printf '输出类型输出格式' 输出内容
        输出类型:
            %ns:    输出字符串. n是数字指代输出几个字符
            %ni:    输出整数. n是数字指代输出几个数字
            %m.nf:    输出浮点数. m和n是数字,指代输出的证整数和小数位数,如%8.2f代表共输出8位,其中2位是小数,6位是整数
        输出格式:
            \a:    输出警告声音
            \b:    输出退格键,也就是Backspace键
            \f:    清除屏幕
            \n:    换行
            \r:    回车
            \t:    水平输出退格键,也就是Tab键
            \v:    垂直输出退格键,也就是Tab键

    [root@localhost ~]# printf %s 1 2 3 4 5 6
    123456    //直接当字符串输出,摞在一起
    [root@localhost ~]# printf %s %s %s 1 2 3 4 5 6
    %s%s123456    //把%s %s 1 2 3 4 5 6当成要输出的内容输出
    [root@localhost ~]# printf '%s %s %s' 1 2 3 4 5 6
    1 2 34 5 6    //输出类型用了引号,所以就以 1 2 3|4 5 6这样的个数输出
    [root@localhost ~]# printf '%s %s %s\n' 1 2 3 4 5 6    //换行输出了!
    1 2 3
    4 5 6
    printf 后面不能接文件名, 也不能通过管道符来接受前面命令的执行结果,如果非要和别的命令一起使用就用下面的操作

    [root@localhost tmp]# vi student.txt
    Id      Name    PHP     Linux   MySQL   Average
    1       Liming  82      95      86      87.66
    2       Sc      74      96      87      85.66
    3       Gao     99      83      93      91.66
    [root@localhost tmp]# printf '%s' $(cat student.txt)    // $(系统命令)
    IdNamePHPLinuxMySQLAverage1Liming82958687.662Sc74968785.663Gao99839391.66
    显示很混乱,要想正常显示就得用下面的操作:
    [root@localhost tmp]# printf '%s\t %s\t %s\t %s\t %s\t %s\n' $(cat student.txt)
    Id     Name     PHP     Linux     MySQL     Average
    1     Liming     82     95     86     87.66
    2     Sc     74     96     87     85.66
    3     Gao     99     83     93     91.66

    在awk命令的输出中支持print和printf命令
        ◆ print: print会在每个输出之后自动加入一个换行符(linux默认没有print命令,只能在awk中使用)
        ◆ printf: printf是标准格式输出命令,并不会自动加入换行符,如果需要换行,需要手工加入换行符,在系统中很少使用
    --------------------------------------------------------------------------------
    11.2.3 字符截取命令 awk
    awk命令格式:
    # awk '条件1{动作1} 条件2{动作2} ...' 文件名
    条件(Pattern):
        一般使用关系表达式作为条件:
        x>10    判断变量x是否大于10
        x>=10   大于等于
        x<=10   小于等于
    动作(Action):
        格式化输出
        流程控制语句
    [root@localhost tmp]# cat student.txt  //查看实例的内容
    Id    Name    PHP    Linux    MySQL    Average
    1    Liming    82    95    86    87.66
    2    Sc    74    96    87    85.66
    3    Gao    99    83    93    91.66
    [root@localhost tmp]# awk '{printf $2 "\t" $6 "\n"}' student.txt  //打印第2列和第6列.第几列用$n表示,"\t"和"\n" 用来调整格式,我们这里没有写条件,表示只要有数据,就全部执行这个动作
    Name    Average
    Liming    87.66
    Sc    85.66
    Gao    91.66

    这里我们再执行查看df -h 命令中某一列信息:
        [root@localhost tmp]# df -h |awk '{print $1 "\t"  $5 "\t"  $6}'
        Filesystem    Use%    Mounted
        /dev/sda5    15%    /
        tmpfs    0%    /dev/shm
        /dev/sda1    19%    /boot
        /dev/sda3    2%    /home
    实例应用:
    硬盘剩余空间监控,监控根分区的容量到达80%就报警.我们这里只要提取一个根分区容量使用 n% 的n数值
    # df -h|grep sda5|awk '{printf $5}'|cut -d "%" -f 1
    # 查看分区空间使用情况| 查找根分区哪一行|查看第五列|以%为分隔符,查看第一列(提取n%中的 n数值)

    awk BEGIN命令    //条件,就是先执行的意思
    # awk 'BEGIN {printf "This is a transcript \n"} {print $2 "\t" $6}' student.txt
    [root@localhost tmp]# awk 'BEGIN {print "This is a transcript"}{print $2 "\t" $5}' student.txt
    This is a transcript
    Name    MySQL
    Liming    86
    Sc    87
    Gao    93
    FS内置变量(作用就是制定分隔符)
    # cat /etc/passwd|grep "/bin/bash" |awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}' //用FS来制定分隔符;注意awk是先读一行数据,再执行操作,所以这里我们在指定分隔符前面,加上BEGIN
    [root@localhost tmp]# cat /etc/passwd|grep "/bin/bash" |awk 'BEGIN {FS=":"} {printf $1 "\t" $3 "\n"}' //一般BEGIN 就是用来指定分隔符和FS连用
    root    0
    END; 与BEGIN相反,所有命令执行结束后再执行
    [root@localhost tmp]# awk 'END{printf "The end \n"} {printf $2 "\t" $6 "\n"}' student.txt
    Name    Average
    Liming    87.66
    Sc    85.66
    Gao    91.66
    The end
    关系运算符

    # cat student.txt|grep -v Name|awk '$6>= 87{printf $2 "\n"}'
    # 查看student.txt内容| 排除包含Name的行|如果这些行中的第6列数值不低于87分,则显示这些行中的第二列
    [root@localhost tmp]# cat student.txt |grep -v Name|awk '$6>=87 {printf $2 "\n"}'
    Liming
    Gao
     --------------------------------------------------------------------------------
    11.2.4 字符截取命令----sed
        sed 是一种几乎包括在所有UNIX平台(包括Linux)的轻量级流编辑器.sed主要是用来将数据进行选取、替换、删除、新增的命令
        vim 也可以增删改.但是vi只能修改已经存在的文件;sed 可以从管道符接受数据来操作,不光可以修改文件内容,也可以直接修改命令的结果
        sed的命令格式
        # sed [选项] '[动作]' 文件名
        选项:
        -n    一般sed命令会把所有的数据都输出到屏幕,如果加入此选择,则会把经过sed命令处理的行输出到屏幕
        -e    允许对输入数据引用多条sed命令编辑
        -i    用sed的修改结果直接修改读取数据的文件,而不是由屏幕输出
        动作:
        a \: 追加,在当前行后添加一行或者多行.添加多行时,除最后一行外,每行末尾都需要用"\"代表数据未完结
        c \: 行替换,用c后面的字符串替换原数据行,替换多行时,除最后一行外,每行末尾需用"\"代表数据未完结
        i \: 插入,在当前行前插入一行或者多行,插入多行时,除最后一行外,每行末尾需要用"\"代表数据未完结
        d: 删除,删除指定的行
        p: 打印,输出指定的行
        s: 字符替换,用一个字符串替换另外一个字符串,格式为"行范围s/旧字串/新字串/g" (和vim中的替换格式类似)
    [root@localhost tmp]# cat student.txt  //用student.txt做例子
    Id    Name    PHP    Linux    MySQL    Average
    1    Liming    82    95    86    87.66
    2    Sc    74    96    87    85.66
    3    Gao    99    83    93    91.66
    [root@localhost tmp]# sed '2p' student.txt  //查看文件的第2行,一般命令,会显示指定的行,还会显示整个文件的数据
    Id    Name    PHP    Linux    MySQL    Average
    1    Liming    82    95    86    87.66
    1    Liming    82    95    86    87.66
    2    Sc    74    96    87    85.66
    3    Gao    99    83    93    91.66
    [root@localhost tmp]# sed -n '2p' student.txt  //只输出经过处理的行,其他没经过处理的行,就不显示,一般带p动作的 都会带-n选项
    1    Liming    82    95    86    87.66

    [root@localhost tmp]# df -h |sed -n '2p'    //sed可以接在管道符后面
    /dev/sda5        16G  2.1G   13G  15% /

    [root@localhost tmp]# sed '2,4d' student.txt    //删除文件内的第2-4行
    Id    Name    PHP    Linux    MySQL    Average

    [root@localhost tmp]# cat student.txt    //查看文件,发现里面的内容其实没有被真实删除,因为 没有-i 选项,只会更改文件的输出,而不会更改文件的本身内容
    Id    Name    PHP    Linux    MySQL    Average
    1    Liming    82    95    86    87.66
    2    Sc    74    96    87    85.66
    3    Gao    99    83    93    91.66

    [root@localhost tmp]# sed '2a hello' student.txt    //在第2行之后插入hello
    Id    Name    PHP    Linux    MySQL    Average
    1    Liming    82    95    86    87.66
    hello
    2    Sc    74    96    87    85.66
    3    Gao    99    83    93    91.66

    [root@localhost tmp]# sed '2i hello \       //插入两行换行
    > weige' student.txt
    Id    Name    PHP    Linux    MySQL    Average
    hello
    weige
    1    Liming    82    95    86    87.66
    2    Sc    74    96    87    85.66
    3    Gao    99    83    93    91.66

    [root@localhost tmp]# sed '2c No such person' student.txt       //用No such person 替换掉第二行
    Id    Name    PHP    Linux    MySQL    Average
    No such person
    2    Sc    74    96    87    85.66
    3    Gao    99    83    93    91.66

    ## 字串替换 ##
    # sed 's/旧字串/新字串/g'文件名

    # sed '3s/74/99/g' student.txt        //把第三行中的74换成99
    # sed -i '3s/74/99/g' student.txt        //把sed操作的数据直接写入文件

    # sed -e 's/Liming//g; s/Gao//g' student.txt        //同时把"Liming"和"Gao"替换为空

    [root@localhost tmp]# sed -e 's/Liming//g ; s/Gao//g' student.txt    //也可以用回车代替";", 只要没输入后面的单引号,系统就会知道这条命令没结束
    Id    Name    PHP    Linux    MySQL    Average
    1        82    95    86    87.66
    2    Sc    74    96    87    85.66
    3        99    83    93    91.66

    PS: 要修改配置文件最好还是用 VIM这样的文本编辑器,少用 sed -i
    --------------------------------------------------------------------------------
    11.3 shell编程-字符处理命令
    1) sort 排序命令
    命令格式: # sort [选项] 文件名
    选项:
        -f:    忽略大小写
        -n:    以数值进行排序,默认使用字符串型排序
        -r:    反向排序
        -t:    指定分隔符,默认分隔符是制表符
        -k n[,m]    按照指定的字段范围排序,从第n字段开始,m字段结束

    2) wc 统计命令
    命令格式# wc [选项] 文件名
    选项:
    -l:     只统计行数
    -w:     只统计单词数
    -m:    只统计字符数
    --------------------------------------------------------------------------------
    11.4 shell编程 条件判断
    条件判断:就是测试一个条件是否成立
    1) 按照文件类型进行判断
    -b 文件    判断该文件是否存在,并且是否为块设备文件(是块设备文件为真)
    -c 文件    判断该文件是否存在,并且是否为字符设备文件(是字符设备文件为真)
    -d 文件    判断该文件是否存在,并且是否为目录文件(是目录为真)
    -e 文件    判断该文件是否存在(存在为真)
    -f 文件    判断该文件是否存在,并且是否为普通文件(是普通文件为真)
    -L 文件    判断该文件是否存在,并且是否为符号链接文件(是符号链接文件为真)
    -p 文件    判断该文件是否存在,并且是否为管道文件(是管道文件为真)
    -s 文件    判断该文件是否存在,并且是否为非空(非空为真)
    -S 文件    判断该文件是否存在,并且是否为套接字文件(是套接字文件为真)
    两种判断格式
    1) # test -e /root/install.log
    2) # [ -e /root/install.log ](shell脚本当中常用第2种格式)

    2) 按照文件权限进行判断
    -r 文件   判断文件是否存在,并且是否该文件拥有读权限(有读权限为真)
    -w 文件   判断文件是否存在,并且是否该文件拥有写权限(有写权限为真)
    -x 文件   判断文件是否存在,并且是否该文件拥有执行权限(有执行权限为真)
    -u 文件   判断文件是否存在,并且是否该文件拥有SUID权限(有SUID权限为真)
    -g 文件   判断文件是否存在,并且是否该文件拥有SGID权限(有SGID权限为真)
    -k 文件   判断文件是否存在,并且是否该文件拥有SBit权限(有SBit权限为真)

    3) 两个文件之间进行比较
        测试选项                                    作用
    文件1 -nt 文件2            判断文件1的修改时间是否比文件2的新(如果新则为真) newer than
    文件1 -ot 文件2            判断文件1的修改时间是否比文件2的旧(如果旧则为真) older than
    文件1 -ef 文件2            判断文件1是否和文件2的Inode号一致,可以理解为两个文件是否为同一个文件.这个判断用于判断硬链接是很好的办法

    4) 连个整数之间的比较
        测试选项                                    作用
    整数1 -eq 整数2            判断整数1是否和整数2相等(相等为真)
    整数1 -ne 整数2            判断整数1是否和整数2不相等(不相等为真)
    整数1 -gt 整数2            判断整数1是否大于整数2(大于为真)
    整数1 -lt 整数2            判断整数1是否小于整数2(小于为真)
    整数1 -ge 整数2            判断整数1是否大于等于整数2(大于等于为真)
    整数1 -le 整数2            判断整数1是否小于等于整数2(小于等于为真)

    5) 字符串的判断
        测试选项                                    作用
        -z 字符串            判断字符串是否为空(为空返回真)
        -n 字符串            判断字符串是否为非空(非空返回真)
        字串1 ==字串2        判断字串1是否和字串2相等(相等返回真)    //shell中=表示给变量赋值,==
        字串1 !=字串2        判断字串1是否和字串2不相等(不相等返回真)

    6) 多重判断
        测试选项                                    作用
    判断1 -a 判断2        逻辑与,判断1和判断2都成立,最终结果才为真
    判断1 -o 判断2        逻辑或,判断1和判断2有一个成立,最终结果就为真
        ! 判断            逻辑非,使原始的判断式取反
    --------------------------------------------------------------------------------
    11.5.1 流程控制-if语句
    1) 单分支if条件语句
    if [ 条件判断式 ]; then
        程序
    fi
    或者
    if [ 条件判断式 ]
        then
            程序
    fi
        单分支注意点

        ◆ if语句使用fi结尾,和一般语言使用大括号结尾不同

        ◆ [ 条件判断式 ]就是使用test命令判断,所以中括号和条件判断式之间必须有空格

        ◆ then后面跟符合条件之后执行的程序,可以放在[]之后,用"; " 分割;也可以用换行写入,就不需           要";"了

        案例:当根目录的使用率超过10% 就输出 Warning!!! /dev/sda5 is full
    #!/bin/bash
    # Author: Aphey
    rate=$(df -h|grep /dev/sda5|awk '{print $5}'|cut -d "%" -f1)

    if [ $rate -ge 10 ]
            then
                    echo "Warning!!! /dev/sda5 is full"
    fi

    2) 双分支if条件语句
    if [ 条件判断式 ]
        then
            条件成立时,执行的程序
        else
            条件不成立时,执行的另一个程序
    fi
        实例1:备份/etc
    #!/bin/bash
    # Author: Aphey

    ntpdate asia.pool.ntp.org &>/dev/null

    date=$(date +%y%m%d)
    size=$(du -sh /etc)

    if [ -d /tmp/dbback ]
            then
                    echo "Date is $date" > /tmp/db.txt
                    echo "Size is $size" >> /tmp/db.txt
                    cd /tmp/dbback
                    tar -zcf etc_$date.tar.gz /etc db.txt &>/dev/null
                    rm -rf /tmp/db.txt
            else
                    mkdir /tmp/dbback
                    echo "Date is $date" > /tmp/db.txt
                    echo "Size is $size" >> /tmp/db.txt
                    cd /tmp/dbback
                    tar -zcf etc_$date.tar.gz /etc db.txt &>/dev/null
                    rm -rf /tmp/db.txt
    fi

        实例2:判断apache是否启动
    #!/bin/bash
    # Author: Aphey

    port=$(nmap -sT 192.168.1.118|grep tcp|grep http|awk '{print $2}')

    if [ "$port" == "open" ]
            then
                    echo "$(date) httpd works well" >> /tmp/httpd_acc.log
            else
                    /etc/rc.d/init.d/httpd restart &>/dev/null
                    echo "$(date) httpd restarted" >> /tmp/httpd_err.log
    fi
    3) 多分支if条件语句
    if [ 条件判断式1 ]
        then
            当条件判断式1成立时,执行程序1
    elif [ 条件判断式2 ]
        then
            当条件判断式2成立时,执行程序2
    ...省略更多条件...
    else
        当所有条件都不成立时,最后执行此程序
    fi
    实例:判断用户输入的是什么文件
    请按 ENTER 或其它命令继续
    #!/bin/bash

    read -p "Please input a filename:" file
    //接受键盘的输入,并赋予变量file

    if [ -z "$file" ]
    //判断变量是否为空
            then
                    echo "Error,please input a filename"
                    exit 1
    elif [ ! -e "$file" ]
    //判断文件是否存在
            then
                    echo "Your input is not a file"
                    exit 2
    elif [ -f "$file" ]
    //判断文件是否为普通文件
            then
                    echo "$file is a regular file!"

    elif [ -d "$file" ]
    //判断file是否为目录文件
            then
                    echo "$file is a directory!"
    else
            echo "$file is an other file!"
    fi
    --------------------------------------------------------------------------------
    11.5.2 流程控制语句 Case语句
    多分支case条件语句
    ◆ case语句和if...elif...else语句一样都是多分支条件语句,不过和if多分支条件语句不同的是,case语句只能判断一种条件关系,而if语句可以判断多种条件关系.
    case语句的格式
    case $变量名 in
        "值1")
            如果变量的值等于值1,则执行程序1
            ;;
        "值2")
            如果变量的值等于值2,则执行程序2
            ;;
        ...省略其他分支...
        *)
        如果变量的值都不是以上的值,则执行此程序
        ;;
    esac
    实例:输入yes/no
    #!/bin/bash
    echo "You have to make your choice by inputting yes or no!"
    read -p "Please choose yes/no: " -t 30 choice
    case $choice in
            "yes")
                    echo "Your choice is yes"
            ;;
            "no")
                    echo "Your choice is no"
            ;;
            *)
                    echo "Your choice is error"
            ;;
    esac
    --------------------------------------------------------------------------------
    11.5.3 for循环
    语法一:
    for 变量 in 值1 值2 值3...    //for后面有几个值就循环几次
        do
            程序
        done
    实例:
    # vi for.sh
    #!/bin/bash
    for time in morning noon afternoon evening
            do
                    echo "It's high $time"
            done
    # ./for.sh
    It's high morning
    It's high noon
    It's high afternoon
    It's high evening

    批量解压缩脚本:
    #!/bin/bash
    cd /lamp
    ls *.tar.gz > ls.log
    for i in $(cat ls.log)
        do
            tar -zxf $i &>/dev/null
        done
        rm -rf /lamp/ls/log

    语法二:
    for((初始值;循环控制条件;变量变化))
        do
            程序
        done
    实例: 从1加到100
    # vi for2.sh
    #!/bin/bash
    s=0
    for ((i=1;i<=100;i=i+1))
            do
                    s=$(($s+$i))
            done
    echo "The sum of 1+2+3+...+100 is: $s"

    [root@localhost tmp]# ./for2.sh
    The sum of 1+2+3+...+100 is: 5050

    实例:批量添加用户
    # vi useradd.sh
    #!/bin/bash

    read -t 30 -p "input name: " name
    read -t 30 -p "input num: " num
    read -t 30 -p "input password: " pass
    if [ ! -z "$name" -a ! -z "$num" -a ! -z "$pass" ]
            then
                    y=$(echo $num|sed 's/^[0-9]$//g')
                    if [ -z "$y" ]
                            then
                                    for((i=1;i<=$num;i=i+1))
                                            do
                                                    /usr/sbin/useradd $name$i &>/dev/null
                                                    echo $pass|/usr/bin/passwd --stdin  $name$i &>/dev/null
                                            done

                    fi

    fi
    --------------------------------------------------------------------------------
    11.5.4 while循环和until循环
    ◆ while循环是不定循环,也称作条件循环.只要条件判断式成立,循环就会一直继续,直到条件判断式不成立,循环才会停止.这就和for的固定循环不太一样了.

    格式
    while [  条件判断式  ]
        do
            程序
        done

    实例: 1加到100
        [root@localhost tmp]# chmod while.sh
        #!/bin/bash
        i=1
        s=0
        while [ $i -le 100  ]
                do
                        s=$(($s+$i))
                        i=$(($i+1))
                done
        echo "The sum is : $s"

        [root@localhost tmp]# ./while.sh
        The sum is : 5050

    2) until循环,和while循环相反,until循环时只要条件判断式不成立则进行循环,并执行循环程序.一旦循环条件成立,则终止循环.
    实例: 1加到100

    [root@localhost tmp]# chmod 755 until.sh
        #!/bin/bash
        i=1
        s=0
        until [ $i -gt 100 ]
                do
                        s=$(($s+$i))
                        i=$(($i+1))
                done
        echo "The sum is: $s"
        [root@localhost tmp]# ./until.sh
        The sum is: 5050
    --------------------------------------------------------------------------------
    --------------------------------------------------------------------------------
    12.1 linux服务管理-服务分类
        1)服务的分类
            ( RPM包默认安装的服务(默认服务)
                ● 独立的服务(服务直接就在内存里,当用户访问服务,服务就直接响应用户)
                    优点:响应速度快        缺点:耗费的资源多
                ● 基于xinetd服务 (本身是独立的,就在内存当中;且本身没功能,但是它管理着一系列的服务,桥梁作用)
                    优点: xinetd管理的服务不在内存中,耗费的资源就少    缺点:响应速度慢
            ( 源码包安装的服务
        启动与自启动
            ( 服务启动:就是在当前系统中让服务运行,并提供功能
            ( 服务自启动:自启动是指让服务在系统开机活着重启之后,随着系统的启动而自动启动服务
        查询已安装的服务
            ( RPM包安装的服务
                ● # chkconfig --list    //查看服务自启动状态,可以且只能看到所有RPM包安装的服务
                2,3,4,5显示开启,表示当我的计算机进行重启,当计算机进入2,3,4,5这4个运行级别中的任意一个,这个服务就会
                随着系统的启动而自动运行,而且显示启用(开)的状态并不代表该服务当前已运行,而是这个服务会随着系统启动下次运行.
                # ps aux    //查看系统中运行的所有进程

            ( 源码包安装的服务
                ● 查看服务的安装位置,一般是/usr/local/下    //不能用命令查询
        RPM安装服务和源码包安装服务的区别(安装位置不同)
            ( 源码包安装在制定位置,一般是/usr/local/
            ( RPM包安装在默认位置中
                ● 一般配置文件会在/etc/下,启动脚本会装在/etc/rc.d/init.d/下,约定俗成的
        所以两者删除方法也不一样,源码包删除文件所在路径即可,而RPM 则用rpm -evh 包名 来删除
    --------------------------------------------------------------------------------
    12.2.1 RPM服务管理-独立服务管理
        RPM包的安装位置
            ( /etc/init.d/: 启动脚本位置,等同于/etc/rc.d/init.d/,独立服务脚本.
            ( /etc/sysconfig/: 初始化环境配置文件位置
            ( /etc/:配置文件位置
            ( /etc/xinetd.conf: xinetd配置文件
            ( /etc/xinetd.d/: 基于xinetd服务的启动脚本
            ( /var/lib/: 服务产生的数据放在这里
            ( /var/log/: 日志
        独立服务的启动
            ( /etc/init.d/独立服务名 start|stop|status|restart
            ( service 独立服务名 start|stop|restart|status    //仅适用CentOS
        独立服务的自启动
            ( chkconfig [--level 运行级别] [独立服务名] [on|off]
                # chkconfig --level 2345 httpd on    //开启apache的自启动,系统默认运行级别为2345,所以 --level 2345 可以省略
            ( 修改/etc/rc.d/rc.local文件,下图2    //只要把需要启动的服务命令完整的添加到此文件中,系统开启的时候就能运行此服务,推荐使用
            ( 使用ntsysv命令管理自启动    #ntsysv    //红帽专有命令,别的Linux未必有此命令
    --------------------------------------------------------------------------------
    12.2 基于xinetd服务管理(了解即可)
        xinetd:超级守护进程
        1) 安装xinetd 与 telnet
        # yum -y install xinetd    //安装xinetd
        # yum -y install telnet-server    //安装telnet,此服务不安全,只是用来做实验

        2) xinetd服务的启动
            # vi /etc/xinetd.d/telnet
            service telnet        //服务的名称为telnet
            {
                flags    =REUSE    //标志位REUSE,设定TCP/IP socket可重用
                socket_type    =stream    //使用TCP协议数据包
                wait    =no    //允许多个连接同时链接
                user    =root    //启动服务的用户为root
                server    =/usr/sbin/in.telnetd    //服务启动程序
                log_on_failure    +=USERID    //登陆失败后,记录用户的ID
                disable    =no    //默认yes服务不启动,改为no则为启动
            }


        3) xinetd服务的自启动(启动和自启动是通用的)
           ( # chkconfig telnet on    //开启telnet自启动
           ( ntsysv    //在ntsysv里开启telnet
    --------------------------------------------------------------------------------
    12.3 源码包服务的管理
        1) 源码包的安装服务的启动
            ( 使用绝对路径,调用启动脚本来启动.不同的源码包的启动脚本不同.可以查看源码包的安装说明,查看启动脚本的方法
             /usr/local/apache2/bin/apacheclt start|stop
        2) 源码包服务的自启动
            # vi /etc/rc.d/rc.local
            加入
            /usr/local/apache2/bin/apachectl start
        3) 让源码包服务被服务管理命令识别(不推荐)
            ( 让源码包的apache服务能被service命令管理启动
            ln -s /usr/bin/apache2/bin/apachectl /etc/init.d/apache
            ( 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动
                # vi /etc/init.d/apache    (下面两句必须有)
                # chkconfig: 35 86 76    //制定httpd脚本可以被chkconfig命令管理.
                # description: source package apache    //说明:内容随意
                  格式:chkconfig: 运行级别 启动顺序 关闭顺序
                    查看系统中现有的服务顺序
                    # ls /etc/rc.d    //显示各运行级别
                    # ls /etc/rc.d/rc3.d/    //查看第3级别下开启顺序和关闭顺序(S开头是开起,K开头是关闭)
                        必须保证新加入的服务启动顺序和关闭顺序不能和现有的顺序重叠
                    # chkconfig --add apache    //把apache加入chkconfig的管理序列,也可以用--del 删除
    --------------------------------------------------------------------------------
    13.1.1 进程管理-进程查看
        1) 进程简介:进程是正在执行的一个程序或一个命令,没一个进程都是一个运行的实体,都有自己的地址空间,并占用一定的系统资源.
            通俗来说就是正在运行的程序.
        2) 进程管理的作用
            ( 判断服务器的健康状态
            ( 查看系统中所有进程
            ( 杀死进程    //正常程序不能退出的时候,才考虑此功能
        3) 查看系统中所有进程
            # ps -aux    //查看系统中所有进程,使用BSD(UNIX,所以aux前没有-,但是不影响)操作系统格式
                  a: 前台进程    u:进程使用者  x:所有后台进程
                [root@localhost rc.d]# ps aux
                            USER        PID %CPU %MEM    VSZ     RSS    TTY      STAT START   TIME  COMMAND
                            root          1         0.0      0.3      56628  6672       ?        Ss     4月22     0:01  /usr/lib/systemd/systemd --switched-root --sys

            # ps -le    //查看系统中所有进程,使用linux标准命令格式
            4)    查看系统健康状况
            # top [选项]        //
            选项:
                -d 秒数: 制定top命令每隔几秒更新.默认是3秒
            在top命令的交互模式当中可以执行的命令
                ?或者h: 显示交互模式的帮助
                P: percentage 以CPU使用率排序,默认就是此项
                M: memory  以内存的使用率排序
                N: 以PID排序
                q: 退出top
        [root@localhost /]# top -d 1
    top - 03:39:37 up 1 day,  3:21,  2 users,  load average: 0.00, 0.01, 0.03
    Tasks: 360 total,   1 running, 359 sleeping,   0 stopped,   0 zombie
    %Cpu(s):  0.2 us,  0.0 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
    KiB Mem :  1870516 total,  1519596 free,   151648 used,   199272 buff/cache
    KiB Swap:  2097148 total,  2097148 free,        0 used.  1542976 avail Mem

    僵尸进程: 就是正在停,还没停止,一般是等一下再看.
        5) 查看进程数
        # pstree [选项]
            选项:
            -p: 显示进程PID
            -u: 显示进程的所属用户
    --------------------------------------------------------------------------------
    13.1.2 进程管理-终止进程
        1) # kill -l    //查看可用的进程信号
                 常用的有1-重启;15(默认)-正常终止;9

        2) # killall [选项] [信号] 进程名    //按照进程名杀死进程
            选项:
            -i: 交互式, 询问是否要杀死某个进程
            -I: 忽略进程名的大小写
        3) pkill命令
        # pkill [选项] [信号] 进程名    //按照进程名终止进程
            选项:
                -t 终端号:  按照终端号提出用户
        Example: # w    //查询本机已经登陆的用户
                 # pkill -t -9 tty1    //强制踢掉系统本机上的用户
    --------------------------------------------------------------------------------
    13.2 工作管理
        1) 把进程放入后台
            ( # tar -zcf etc.tar.gz   /etc &
            ( # top    //在top命令执行过程中按下ctrl+z键,会暂停运行
        2) 查看后台的工作
            # jobs [-l]
                选项: -l 显示工作的PID,
                    "+"表示最近一个放入后台的工作,也是工作恢复时,默认恢复的工作
                    "-"表示倒数第二个放入后台的工作
        3) 将后台暂停的工作恢复到前台执行
            # fg %工作号
            参数: %工作号--- %号可以省略,但是注意工作号和PID的区别
        4) 把后台暂停的工作恢复到后台执行
            # bg %工作号    //注意:后台恢复执行的命令,是不能和前台有交互的,否则不能回复到后台执行.如top命令和vi命令.
    --------------------------------------------------------------------------------
    13.3 Linux系统管理-系统资源查看
        1) vmstat命令监控系统资源
            # vmstat    [刷新延迟 刷新次数]
            如: # vmstat 1 3
        2) dmesg开机内核检测信息
            # dmesg    //开机内核检测信息
            # dmesg | grep CPU
        3) free命令查看内存使用状态
            # free [-b|-k|-m|-g]
            选项:
            -b: 以字节为单位显示
            -k: 以KB为单位显示,默认就是KB
            -m: 以MB为单位显示
            -g: 以GB为单位显示

        缓存和缓冲的区别
        ( 简单来说缓存(cache)是用来加速数据从硬盘中读取的,先从硬盘读取到内存中,程序从内存中读取;
          而缓冲(buffer)是用来加速数据"写入"硬盘的,先写入内存,保存到一定量,再从内存中写入硬盘.
        4) 查看CPU信息
           # cat/proc/cpuinfo    //每次开机,就会读取CPU信息,然后写入此文件
        5) uptime命令
            # uptime    //显示系统的启动时间和平均负载,也就是top的第一行.w命令也可以看到这个数据.
        6) 查看系统与内核相关信息
            # uname [选项]
            选项:
                -a: 查看系统所有相关信息
                -r: 查看内核版本
                -s: 查看内核名称
            判断当前系统的位数: # file /bin/ls
            查询当前系统的发行版本: # lsb_release -a    或者 # cat /etc/os-release
        7) 列出进程打开或使用的文件信息
            # lsof [选项]    //列出进程调用或打开的文件信息
               选项:
                -c 字符串: 只列出以字符串开头的进程打开的文件
                -u 用户名: 只列出某个用户的进程打开的文件
                -p pid: 列出某个PID进程打开的文件
    --------------------------------------------------------------------------------
    13.4 系统的定时任务
        1) crond服务管理与访问控制 (cron daemon-进程)
            # service crond restart    //重启crond服务
            # chkconfig crond on        //开机启crond动crond,系统默认是自动启动的
        2) 用户的crontab设置
            # crontab [选项]
                选项:
                -e: 编辑crontab定时任务
                -l: 查询crontab任务
                -r: 删除当前用户所有的rontab任务
            # crontab -e    //进入crontab编辑界面.会打开vim编辑你的工作
                ***** 执行的任务    //10 **** ,表示每小时的第10分钟执行
                注释:
                    项目                    含义                    范围
                    第一个"*"            一小时中的第几分钟            0-59
                    第二个"*"            一天当中的第几个小时           0-23
                    第三个"*"            一个月当中的第几天            1-31
                    第四个"*"            一年当中的第几个月            1-12
                    第五个"*"            一周当中的星期几              0-7(0和7都是星期天)

                    特殊符号            含义
                    *                代表任何时间.比如第一个"*"就代表一小时中每分钟都执行一次
                    ,                代表不连续的时间.如"0 8,12,16 *** 命令",表示每天的8点0分,12点0分,16点0分都执行一次命令
                    -                代表连续的时间范围.如"0 5 ** 1-6 命令",代表在周一到周六的早上5点0分执行命令
                    */n              代表每隔多久执行一次.比如"*/10 **** 命令",代表没隔10分钟就执行一遍命令

                    例子                    解释
                45 22 *** 命令            在22点45分执行命令
                0 17 ** 1 命令            每周一的17点0分执行命令
                0 5 1,15 ** 命令          每月的1号和15号的早上5点0分执行命令
                40 4 ** 1-5 命令          每周一到周五的凌晨4点40分执行命令
                */10 4 *** 命令           每天凌晨4点整开始没隔10分钟执行一次命令,执行6次
                0 0 1,15 * 1 命令         每月1号和15号,以及每周一的0点0分都会执行命令,星期和日期最好不要同时出现.
    --------------------------------------------------------------------------------
    14.1 日志管理
        1) 日志服务
           ( 在CentOS 6中日志服务已经有rsyslogd取代了原先的syslogd服务.rsyslogd日志服务更加先进,功能更多.
            但是不论该服务的使用还是日志文件的格式其实都是和syslogd服务相兼容的,所以学习起来基本和syslogd服务一样.
            确定服务启动
            # ps aux | grep rsyslogd    //查看服务是否启动
            #chkconfig --list | grep rsyslogd    //查看服务是否自启动
        2) 常用日志的作用
            日志文件                        说明
           /var/log/cron                记录了系统定时任务相关的日志
           /var/log/cups                记录了打印信息的日志
           /var/log/dmesg               记录了系统在开机时内核自检的信息.也可以使用dmesg命令直接查看内核自检信息.
           /var/log/btmp                记录错误登陆的日志.这个文件是二进制文件,不能直接vi查看,要用lastb命令看
                                        # lastb
           root    tty1    Tue Jun 4 22:38-22:38(00:00)  //    有人在6月4号使用root用户在本地终端1登陆错误
           /var/log/lastlog              记录系统中所有用户最后一次的登陆时间的日志.这个文件也是二进制文件,用lastlog查看
           /var/log/mailog               记录邮件信息
           /var/log/messages             记录系统重要信息的日志.这个日志文件中会记录Linux系统的绝大多数重要信息,如果系统中出现问题时,
                                         首先要检查的就是这个日志文件
            /var/log/secure              记录验证和授权方面的信息,只要设计账户和密码的程序都会记录.比如说系统的登陆,ssh的登陆,su切换用户,
                                         sudo授权,甚至添加用户和修改用户密码都会记录在这个日志文件中.
            /var/log/wtmp                永久记录所有用户的登陆、注销信息,同时记录系统的启动,重启,关机时间.同样这个文件也是二进制文件,
                                         不能vi,而要用last命令查看
            /var/run/utmp                记录当前已经登陆的用户信息,这个文件会随着用户的登陆和注销而不断变化,之记录当前登录用户的信息.
                                         同样这个文件不能vi,而要用w,who,user等玲玲来查询.
        ■ 除了系统默认的日志以外,采用RPM方式安装的系统服务业会默认把日志记录在/var/log目录中(源码包安装的服务日志是在源码包指定目录中).
         不过这些日志不是由rsyslogd服务来记录和管理的,而是哥哥服务使用自己的日志管理文档来记录自身日志.
            RPM包日志文件                        说明
            /var/log/httpd/                RPM包安装的apache服务的默认日志目录
            /var/log/mail/                 RPM包安装的邮件服务的额外日志目录
            /var/log/samba/                RPM包安装的samba服务的日志记录
            /var/log/sssd/                 守护进程安全服务目录
    --------------------------------------------------------------------------------
    14.2 rsyslogd服务
        1) 日志文件格式
            ( 基本日志格式包含以下四列
                ● 时间产生的时间;
                ● 发生时间的服务器的主机名;
                ● 产生时间的服务名或程序名;
                ● 产生事件的服务名或程序名;
                ● 时间的具体信息
        2) /etc/rsyslog.conf 配置文件
              authpriv        .            *                        /var/log/secure
            //服务名称    [链接符号]    日志等级                       日志记录位置
            //认证相关服务,所有日志等级                            记录在/var/log/secure日志中
                服务名称                    说明
                auth                    安全和认证相关信息(不推荐使用authpriv替代)
                authpriv                安全和认证相关消息(私有的)
                cron                    系统定时任务cront和at产生的日志
                daemon                  和各个守护进程相关的日志
                ftp                     ftp守护进程产生的日志
                kern                    内核产生的日志(不是用户进程产生的)
                local10-local7          为本地使用预留的服务
                lpr                     打印产生的日志
            ( 链接符号
                ● "*"代表所有的日志等级,比如:"authpriv.*" 代表authpriv认证信息服务产生的日志,所有的日志等级都记录
                ● "."代表只要比后面的等级高的(包含该等级) 日志都要记录下来.比如"cron.info"代表cron服务产生的日志,只要
                日志等级大于等于info级别,就记录
                ● ".="代表只记录所需等级的日志,其他等级的都不记录.比如"*=emerg"代表人和日志服务产生的日志,只要等级是
                emerg等级的就记录.这种用法及其少见,了解即可
                ● ".!"代表不等于,也就是除了该等级的日之外,其他等级的日志都记录
             日志等级
                        等级名称                        说明
                        debug                    一般调试信息说明
                        info                     基本的通知信息
                        notice                   普通信息,但是有一定的重要性
                        warning                  警告信息,但是还不会影响到服务或系统的运行
                        err                      错误信息,一般达到err等级的信息以及可以影响到服务或者系统的运行
                        crit                     临街状况信息,比err等级还要严重
                        alert                    经过好状态信息,比crit还要严重.必须立即采取行动
                        emerg                    疼痛等级信息,系统已经无法使用了
             日志记录位置
                ( 日志文件的绝对路径.如 "/var/log/secure"
                ( 系统设备文件,如"/dev/lp0"
                ( 转发给远程主机,如"@192.168.0.210:514"
                ( 用户名,如"root"
                ( 忽略或丢弃日志,如"~"
    --------------------------------------------------------------------------------
    14.3 日志轮替
        轮替: 把日志切割开来(按天或者其他单位把日志分成很多份);按一定的周期,删除以前的保留新产生的日志
        1) 日志文件的命名规则
            ( 如果配置文件中拥有"dateext" 参数,那么日志就会用日期来作为日志文件的后缀,
            例如"secure-20130605".这样的话日志文件名不会重叠,所以就不需要日志文件改名,
            只需要保存制定的日志个数,删除多余的日志文件即可.
            ( 如果配置文件中没有"dateext"参数,那么日志文件就需要进行改名了,当第一次进行
            日志轮替时,当前的"secure"日志会自动改名为"secure.1",然后新建"secure"日志,
            用来保存新的日志.当第二次进行日志轮替时,"secure.1"会自动改名为"secure.2",
            当前的"secure"日志会自动改名为"secure.1",然后也会新建"secure"日志,用来保存
            新的日志,以此类推.

        2) logrotate配置文件    /etc/logrotate.conf
            注意,配置文件中的 大括号里的配置优先级比上面的配置优先级要高,
                就是说会按照大括号里的配置执行

            参数                    参数说明
            daily                 日志的轮替周期是每天
            weekly                日志的轮替周期是每周
            monthly               日志的轮替周期是每月
            rotate 数字           保留日志文件的个数.0是指没有备份
            compress              日志轮替时,旧的日志进行压缩
            create mode owner group        建立新日志,同时制定新日志的权限与所有者和所属组.如 create 0600 root utmp
            mail address          当日志轮替时,输出内容通过邮件发送到指定的邮件地址.如 mail y2j@qq.com
            missingok             如果日志不存在,则忽略该日志的警告信息
            notifempty            如果日志为空文件,则不进行日志轮替
            minsize 大小           入职轮替的最小值. 也就是日志一定要达到这个最小值才会轮替,否则就是时间达到也不轮替
            size 大小              日志只有大于制定大小才进行日志轮替,而不是按照时间轮替.如 size 100k
            dateext                使用日期作为日志轮替文件的后缀.如secure-20130605

        3) 把apache日志加入轮替 (rpm包默认自动轮替,且会自动按照轮替配置执行,需要我们配置的是源码包的日志)
            # vi /etc/logrotate.conf
            /usr/local/apache2/logs/access_log{
            daily
            create
            rotate 30
            }
        4) logrotate命令
            # logrotate [选项] 配置文件名
                选项:
                如果此命令没有选项,则会按照配置文件中的条件进行日志轮替
                -v: 显示日志轮替过程. 加了-v 选项,会显示日志的轮替过程
                -f: 强制执行日志轮替.不管日志轮替的条件是否已经符合,强制配置文件中所有的日志进行轮替
    --------------------------------------------------------------------------------
    15.1  启动流程-运行级别
        1) 运行级别
            运行级别            含义
               0            关机
               1            单系统用户模式, 可以想象为windows的安全模式,主要用于系统修复
               2            不完全的命令模式,不含NFS服务
               3            完全的命令模式,就是标准字符界面
               4            系统保留
               5            图形模式
               6            重新启动
        2) 运行级别命令
            # runlevel    //查看运行级别命令
            # init 运行级别    //改变运行级别命令    不推荐用此命令
        3) 系统默认运行级别
            # vim /etc/inittab
              id:3:initdefault:    //系统开机后直接进入哪个运行级别
    --------------------------------------------------------------------------------
    15.2.1 启动引导程序-Grub配置文件
        1) grub中分区表示
            硬盘            分区                Linux中设备文件名            Grub中设备文件名
                           1st 主分区                /dev/sda1                hd(0,0)
           1st SCSI HD     2nd 主分区                /dev/sda2                hd(0,1)
                           扩展分区                  /dev/sda3                hd(0,2)
                           1st 逻辑分区              /dev/sda5                hd(0,4)

                           1st 主分区                /dev/sdb1                hd(1,0)
           2nd SCSI HD     2nd 主分区                /dev/sdb2                hd(1,1)
                           扩展分区                  /dev/sdb3                hd(1,2)
                           1st 逻辑分区              /dev/sdb5                hd(1,4)
        2) Grub配置文件
         #   vi/etc/grub/grub.conf  (CentOS 7: #vi /boot/grub2/grub.cfg)
          ( default=0        //默认启动第一个系统
          ( timeout=5        //等待时间默认5秒
          ( splashimage=(hd0,0)/grub/splash.xpm.gz   //这里是制定grub启动时的北京图像文件的保存位置
          ( hiddenmenu        //隐藏菜单
          ( title ***(仅限于CentOS 6.x版本 )
            // 就是标题
          ( root (hd0,0)    //是指启动程序的保存分区
          ( kernel //内核信息,一般不推荐更新,除非有重大问题爆发,尽量不要升级,特别不能远程升级
          ( initrd /initramfs-2.6...    //制订了initramfs内存文件系统镜像文件的所在位置
    --------------------------------------------------------------------------------
    15.2.2 启动引导程序---Grub加密(就是开机的时候,不能随意按e编辑grub配置)
        1) grub加密(仅适用于CentOS6 )
            # grub-md5-crypt    //输入此命令,会让你输入密码,然后生成加密密码串
            # vi /boot/grub/grub.conf
              default=0
              timeout=5
              password--md5
                此处输入上面生成的密码串    //password选项放在整体设置,放在背景图这一行之前.
              splashimage=(hd0,0)/grub/splash.xpm.gz
              hiddenmenu
              .....
        2) 字符界面分辨率修改
            # grep　"CONFIG_FRAMEBUFFER_CONSOLE" /boot/config-2.6.32-279.e16.i686    //查询是否支持分辨率修改
            # vi /boot/grub2/grub.cfg
                    找到下面这句话
             linux16 /vmlinuz-0-rescue-510bad862bc340708a2cb443e46a980b
                    root=/dev/mapper/centos-root ro rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet
                    在后面添加 VGA=795
    --------------------------------------------------------------------------------
    CENTOS 7 进入单用户方法
        init方法
        1、centos7的grub2界面会有两个入口，正常系统入口和救援模式；
        2、修改grub2引导
            在正常系统入口上按下"e"，会进入edit模式，搜寻ro那一行，以linux16开头的；
            把ro更改成rw；（把只读更改成可写）
            把rhgb quiet删除；（quiet模式没有代码行唰唰的走，可以删除）
            增加init=/bin/sh；（或init=/bin/bash,指定shell环境)
            按下ctrl+x来启动系统。
        3、修改root密码
            #passwd                       #修改密码
            #touch /.autorelabel      #据说是selinux在重启后更新label
            #exec /sbin/init              #正常启动init进程

        另外还有一种rd.break方法（未尝试）
        1、启动的时候，在启动界面，相应启动项，内核名称上按“e”；
        2、进入后，找到linux16开头的地方，按“end”键到最后，输入rd.break，按ctrl+x进入；
        3、进去后输入命令mount，发现根为/sysroot/，并且不能写，/只有ro=readonly权限；
        4、mount -o remount,rw /sysroot/，重新挂载，之后mount，发现有了r,w权限；
        5、chroot /sysroot/ 改变根；
        （1）echo redhat|passwd –stdin root 修改root密码为redhat，或者输入passwd，交互修改；
        （2）还有就是先cp一份，然后修改/etc/shadow文件
        6、touch /.autorelabel 这句是为了selinux生效
        7、ctrl+d 退出
    --------------------------------------------------------------------------------
    15.3 启动管理-系统修复模式
        1) 单用户模式(开启方式: 开机读秒的时候按e进入GRUB的三句话光标移到 Kernel,再按e在quiet后面输1，再按B就可以进入多用户模式)
            单用户模式常见错误修复
                ( 遗忘root密码
                ( 修改系统默认运行级别

        CENTOS 7 进入单用户方法
        init方法
        1、centos7的grub2界面会有两个入口，正常系统入口和救援模式；
        2、修改grub2引导
            在正常系统入口上按下"e"，会进入edit模式，搜寻ro那一行，以linux16开头的；
            把ro更改成rw；（把只读更改成可写）
            把rhgb quiet删除；（quiet模式没有代码行唰唰的走，可以删除）
            增加init=/bin/sh；（或init=/bin/bash,指定shell环境)
            按下ctrl+x来启动系统。
        3、修改root密码
            #passwd                       #修改密码
            #touch /.autorelabel      #据说是selinux在重启后更新label
            #exec /sbin/init              #正常启动init进程

        另外还有一种rd.break方法（未尝试）
        1、启动的时候，在启动界面，相应启动项，内核名称上按“e”；
        2、进入后，找到linux16开头的地方，按“end”键到最后，输入rd.break，按ctrl+x进入；
        3、进去后输入命令mount，发现根为/sysroot/，并且不能写，只有ro=readonly权限；
        4、mount -o remount,rw /sysroot/，重新挂载，之后mount，发现有了r,w权限；
        5、chroot /sysroot/ 改变根；
        （1）echo redhat|passwd –stdin root 修改root密码为redhat，或者输入passwd，交互修改；
        （2）还有就是先cp一份，然后修改/etc/shadow文件
        6、touch /.autorelabel 这句是为了selinux生效
        7、ctrl+d 退出
        8、然后reboot

        2) 光盘修复模式
         放入光盘,把首选启动项改为光盘,然后选择第三项rescue installed system...然后一直 OK
        选择 shell  start shell 然后一直OK
         进入shell 后,此时所处的系统跟是光盘模拟的.要进入原系统根 输入:
         # chroot /mnt/sysimage/
        此时就是原系统的根目录,并进入了真正的修复模式
        bash-4.1# chroot /mnt/sysimage    //改变主目录
        Example:(丢失了inittab文件)
        sh-4.1# rpm-qf /etc/inittab    //查询下/etc/inittab文件属于哪个包
        sh-4.1# mkdir /mnt/cdrom       //建立挂载点
        sh-4.1# mount /dev/sr0 /mnt/cdrom    //挂载光盘
        sh-4.1# rpm2cpio /mnt/cdrom/Packages/initscripts-8.45.3-1.i386.rpm | cpio -idv ./etc/inittab    //提取inittab文件到当前目录
        sh-4.1# cp /etc/inittab /etc/inittab    //赋值inittab 文件到指定位置
    --------------------------------------------------------------------------------
    16.1 备份与恢复
        1) Linux 系统需要备份的数据
        ( /root/目录
        ( /home/目录
        ( /var/spool/mail/ 目录
        ( /etc/目录
        ( 其他目录
        安装服务的数据
        ( apache需要备份的数据
            ● 配置文件
            ● 网页主目录
            ● 日志文件
        ( mysql需要备份的数据
            ● 源码包安装的mysql: /usr/local/mysql/data
            ● rpm包安装的mysql: /var/lib/mysql
        2)    备份策略
            ( 完全备份: 完全备份就是指把所有需要备份的数据全部备份,当然完全备份可以备份
        整块硬盘,整个分区或某个具体的目录
            ( 增量备份: 每次备份只备份新增加的部分,只是跟上一次备份相比.缺点是恢复起来非常麻烦
        有多少次增量备份就要恢复多少次.
            ( 差异备份: 每次备份和第一次备份的差异,修改不同的地方.只是完整备份和增量备份的折中.
    --------------------------------------------------------------------------------
    16.2 备份与还原-dump和restore
        1) dump命令(系统默认是没安装的,需要手动安装)
         # dump [选项] 备份之后的文件名 源文件或目录
            选项:
                -level: 就是我们说的0-9是个备份备份级别(直接就是 -0,就是完全备份, -1就是第一次增量备份)
                -f 文件名: 指定备份之后的文件名
                -u: 备份成功之后,把备份时间记录在/etc/dunpdates文件
                -v: 显示备份过程中更多的输出信息
                -j: 调用bzlib库压缩备份文件,其实就是把备份文件压缩为.bz2格式
                -W: 显示允许被dump的分区的备份登记及备份时间
        Example:
            # dump-0uj -f /root/boot/bak.bz2 /boot/    //备份命令.先执行一次完全备份,并压缩和更新备份时间;
    # cat /etc/dumpdates    // 查看备份时间文件
            # cp install.log /boot/    //复制日志文件到/boot分区
            # dump -1 uj -f /root/boot.bak1.bz2 /boot/    //增量备份/boot分区,并压缩下图3
            # dump -W    //查询分区的备份时间及备份级别 下图4
        备份文件或目录
        # dump -oj -f /root/etc.dump.bz2 /etc/    //完全备份/etc/目录
        备份目录只能是0级别进行备份,而不再支持增量备份;只有对分区进行备份的时候,才能进行增量备份,如果增量备份目录,就会出错
        2) restore命令
            # restore [模式选项] [选项]
                模式选项: restotre 命令常用的模式有以下四种,这四个模式不能混用.
                    -C: 比较备份数据和实际数据的变化
                    -i: 进入交互模式,手工选择需要回复的文件.
                    -t: 查看模式,用于查看备份文件中拥有那些数据
                    -r: 还原模式,用于数据还原.
                选项:
                    -f: 指定备份文件的文件名
            ( 比较备份数据和实际数据的变化
            # mv /boot/vmlinuz-2.6.32-279.el6.i686 /boot/vmlinuz-2.6.32-279.el6.i686.bak
             // 把/boot目录中内核镜像文件改个名字
            # restore -C -f /root/boot.bak.bz2    //restore 发现内核镜像文件丢失

            ( 查看模式
            # restore -t -f boot.bak.bz2    //可以查看到备份的压缩包中有那些数据

        ( 还原模式
          还原boot.bak.bz2分区备份
          先还原完全备份的数据
          # mkdir boot.test    //新建一个 boot.test文件夹
          # cd boot.test        //进入boot.test文件夹
          # restore -r -f /root/boot.bak.bz2    //解压缩
          # resotre -r -f /root/boot.bak1.bz2    //回复增量备份数据

      ( 还原文件
        还原/etc/目录的备份etc.dump.bz2
        # restore -r -f etc.dump.bz2    //还原etc.dump.bz2备份
    --------------------------------------------------------------------------------
    云计算和集群
        ( 服务器集群是什么(百度的解释)
        集群是一组相互独立的,通过告诉网络互联的计算机,它们构成一个组,并以单一系统的模式加以管理,
        一个客户与集群相互作用时,集群像是一个独立的服务器,集群配置是用于提高可用性和可缩放性

        ( 集群的分类
            ● 科学技术型集群
            ● 附在均衡性集群
            ● 高可用性集群
        ( 云计算(百度的解释)
           云就算是一种按照使用量付费的模式,这种模式提供可用的,便捷的,按需的网络访问,进入可配置的计算资源共享池
           (资源包括网络,服务器,存储,应用软件,服务),这些资源能够被快速提供,秩序投入很少的管理工作,或与服务供应商
           进行很少的交互.

        ( 云计算的模式
        Iaas(云计算Inframestructure  as a service): 基础设施
        IaaS, Infrastructure as a service:基础设施即服务
            Iaas 是通过因特网,以服务的形式提供运算能力、存储设备、网络及其他基础设施
            常见的亚马逊的AWS,谷歌的GCE,IBM的BlueCloud和阿里云都是Iaas
        ( Paas (Platform as a Service) 平台即服务
            Paas 与Iaas类似,也会通过互联网以服务的形式提供运算能力,存储设备,网络等服务.
            但是Paas使用的只是一个应用程序,而不像IaaS是整个机器的虚拟镜像.
            ●八百客的800app等是典型应用
        ( Saas (Software as a Service) 软件即服务
            把应用软件通过网络以服务形式提供给客户
            Google Docs 和 Google Apps 是常见的 SaaS服务
    云计算分类
        ( 私有云 自己搭建的云平台(大公司,买得起足够的服务器)
        ( 公有云 AWS 或者阿里云等(一般都是中小公司和个人用户)
    云计算的典型应用
        ( 云平台 (AWS 阿里云等)
        ( 云存储 (Icloud )
        ( 在线办公
        ( 地图导航
        ( 地图导航
        ( 电子商务
        ( 搜索引擎
    云计算的优势
        ( 更节约成本
        ( 可以简单方便的实现可扩展性
        ( 高可用性
        ( 可测试性
    云计算和Linux的关系
        ( 虚拟化技术是构建云计算基础架构不可或缺的关键技术,常见的虚拟化解决方案:
        Xen,KVM,VMware等,云计算是Linux众多服务中的一个而已
    --------------------------------------------------------------------------------
